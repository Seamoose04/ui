{"entries":[{"timestamp":1743710361200,"editorVersion":"2.0.46","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":94,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":149,"length1":58,"diffs":[[1,"        \"assets.json\"\n"]]},{"start1":210,"length1":45,"diffs":[[1,"    \"languageRestriction\": \"javascript-only\",\n    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"ui.ts","value":"namespace UI {\n    enum PositionMethod {\n        CENTER,\n        TOP_LEFT\n    }\n\n    export class Display {\n        ctx: Image\n        constructor() {\n            this.ctx = image.create(screen.width, screen.height)\n        }\n        clear() {\n            this.ctx.fill(game.Color.Transparent)\n        }\n        show() {\n            scene.setBackgroundImage(this.ctx)\n        }\n    }\n\n    abstract class Element {\n        parent: Element\n        children: Element[]\n        constructor() {\n            this.parent = null\n            this.children = []\n        }\n        abstract draw(ctx: Image): void\n        setParent(element: Element): void {\n            this.parent = element\n            element.children.push(this)\n        }\n    }\n\n    interface Outline {\n        border: boolean\n        borderColor: color\n        borderWidth: number\n    }\n\n    interface Position {\n        position: Vector2\n        positionMethod: PositionMethod\n        size: Vector2\n    }\n\n    export class Box extends Element implements Outline, Position {\n        position: Vector2\n        positionMethod: PositionMethod\n        size: Vector2\n        color: color\n        border: boolean\n        borderColor: color\n        borderWidth: number\n\n        constructor(position: Vector2, size: Vector2, color?: color) {\n            super()\n            this.position = position\n            this.positionMethod = PositionMethod.CENTER\n            this.size = size\n            this.color = game.Color.Tan\n            if (color) {\n                this.color = color\n            }\n            this.border = false\n            this.borderWidth = 1\n            this.borderColor = game.Color.Black\n        }\n\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    if (this.border) {\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2, this.position.y - this.size.y / 2,\n                            this.size.x, this.size.y,\n                            this.borderColor\n                        )\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2 + this.borderWidth,\n                            this.position.y - this.size.y / 2 + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2, this.position.y - this.size.y / 2,\n                            this.size.x, this.size.y,\n                            this.color\n                        )\n                    }\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    if (this.border) {\n                        ctx.fillRect(\n                            this.position.x, this.position.y,\n                            this.size.x, this.size.y,\n                            this.borderColor\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth, this.position.y + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillRect(\n                            this.position.x, this.position.y,\n                            this.size.x, this.size.y,\n                            this.color\n                        )\n                    }\n                    break\n                }\n            }\n        }\n    }\n}"},{"type":"added","filename":"util.ts","value":"class Vector2 {\n    x: number\n    y: number\n    constructor(x: number, y: number) {\n        this.x = x\n        this.y = y\n    }\n}"}]},{"timestamp":1743711616552,"editorVersion":"2.0.46","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":28,"length1":63,"diffs":[[1,"// let rect = new UI.Box(new Vector2(80, 60), new Vector2(40, 30))"]]}]}]},{"timestamp":1743711624692,"editorVersion":"2.0.46","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":28,"length1":93,"diffs":[[1,"let rect = new UI.Box(new Vector2(80, 60), new Vector2(40, 30))"]]}]},{"type":"edited","filename":"ui.ts","patch":[{"start1":385,"length1":20,"diffs":[[1,"    abstract class Element {\n"]]},{"start1":562,"length1":35,"diffs":[[1,"        abstract draw(ctx: Image): void\n"]]},{"start1":3771,"length1":6,"diffs":[[1,""]]}]}]},{"timestamp":1743712221016,"editorVersion":"2.0.46","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":1107,"length1":1,"diffs":[[1,""]]},{"start1":1128,"length1":1,"diffs":[[1,""]]},{"start1":3758,"length1":1145,"diffs":[[1,"    \n"]]}]}]},{"timestamp":1743712818341,"editorVersion":"2.0.46","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":111,"length1":138,"diffs":[[1,""]]}]},{"type":"edited","filename":"ui.ts","patch":[{"start1":4261,"length1":70,"diffs":[[1,"            this.size = new Vector2(this.radius, this.radius)\n"]]},{"start1":4723,"length1":348,"diffs":[[1,"                        ctx.fillCircle(this.position.x, this.position.y, this.radius)\n"]]},{"start1":4875,"length1":557,"diffs":[[1,""]]},{"start1":4905,"length1":267,"diffs":[[1,""]]}]}]},{"timestamp":1743713378346,"editorVersion":"2.0.46","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":5993,"length1":382,"diffs":[[1,""]]}]}]},{"timestamp":1743713975531,"editorVersion":"2.0.46","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":6260,"length1":1329,"diffs":[[1,"                    let top = this.position.y \n"]]}]}]},{"timestamp":1743714569993,"editorVersion":"2.0.46","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":7015,"length1":1166,"diffs":[[1,"                        ctx.fillCircle(left + this.borderWidth, top - this.borderWidth, this.cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(left + this.borderWidth, top - this.borderWidth, this.cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(left + this.borderWidth, top - this.borderWidth, this.cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(left + this.borderWidth, top - this.borderWidth, this.cornerRadius - this.borderWidth, this.color)\n"]]}]}]},{"timestamp":1743716242263,"editorVersion":"2.0.46","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":28,"length1":6,"diffs":[[1,"let rect = new UI.Box(new Vector2(80, 60), new Vector2(40, 30))\r\nrect.draw(d.ctx)\r\nlet circle = new UI.Circle(new Vector2(80, 60), 10, game.Color.Orange)\r\ncircle.border = true\r\ncircle.borderWidth = 2\r\ncircle.draw(d.ctx)\r\n"]]}]}]},{"timestamp":1743716245422,"editorVersion":"2.0.46","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":28,"length1":11,"diffs":[[1,"let \r\n"]]}]}]},{"timestamp":1743725371006,"editorVersion":"2.0.46","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":28,"length1":23,"diffs":[[1,"let rb = \r\n"]]}]}]},{"timestamp":1743725374137,"editorVersion":"2.0.46","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":28,"length1":189,"diffs":[[1,"let rb = new UI.Rounf\r\n\r\n"]]}]},{"type":"edited","filename":"ui.ts","patch":[{"start1":15,"length1":33,"diffs":[[1,"    enum PositionMethod {\n"]]},{"start1":7015,"length1":576,"diffs":[[1,"                        ctx.fillCircle(left + this.borderWidth, top + this.borderWidth, this.cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(left + this.borderWidth, bottom - this.borderWidth, this.cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right - this.borderWidth, top + this.borderWidth, this.cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right - this.borderWidth, bottom - this.borderWidth, this.cornerRadius - this.borderWidth, this.color)\n"]]},{"start1":8015,"length1":101,"diffs":[[1,"                            this.size.y - this.borderWidth * 2, bottom - top - this.borderWidth * 2,\n"]]}]}]},{"timestamp":1743725968367,"editorVersion":"2.0.46","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":28,"length1":71,"diffs":[[1,"let rb = new UI.RoundedBox(new Vector2(80, 60), new Vector2(50, 60), 5)\r\n"]]},{"start1":201,"length1":148,"diffs":[[1,"rb.draw(d.ctx)\r\nd.show()"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":65,"length1":53,"diffs":[[1,"        \"device\": \"*\"\n"]]}]},{"type":"edited","filename":"ui.ts","patch":[{"start1":251,"length1":44,"diffs":[[1,"            this.ctx.fill(game.Color.Transparent)\n"]]},{"start1":7022,"length1":484,"diffs":[[1,"                        ctx.fillCircle(left + this.borderWidth, top + this.borderWidth, this.cornerRadius - this.borderWidth / 2, this.color)\n                        ctx.fillCircle(right - this.borderWidth, top + this.borderWidth, this.cornerRadius - this.borderWidth / 2, this.color)\n                        ctx.fillCircle(left + this.borderWidth, bottom - this.borderWidth, this.cornerRadius - this.borderWidth / 2, this.color)\n                        ctx.fillCircle(right - this.borderWidth, bottom - this.borderWidth, this.cornerRadius - this.borderWidth / 2, this.color)\n"]]}]}]},{"timestamp":1743726577996,"editorVersion":"2.0.46","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":201,"length1":16,"diffs":[[1,""]]}]}]},{"timestamp":1743726585104,"editorVersion":"2.0.46","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":28,"length1":72,"diffs":[[1,"let rb = new UI.RoundedBox(new Vector2(0, 0), new Vector2(50, 60), 6)\r\n"]]},{"start1":201,"length1":177,"diffs":[[1,"let r = new \r\n"]]},{"start1":310,"length1":36,"diffs":[[1,""]]},{"start1":327,"length1":19,"diffs":[[1,""]]}]},{"type":"edited","filename":"ui.ts","patch":[{"start1":6112,"length1":71,"diffs":[[1,"                    let left = this.position.x + this.cornerRadius\n"]]},{"start1":6261,"length1":70,"diffs":[[1,"                    let top = this.position.y + this.cornerRadius\n"]]},{"start1":8172,"length1":375,"diffs":[[1,""]]}]}]},{"timestamp":1743727183138,"editorVersion":"2.0.46","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":8489,"length1":87,"diffs":[[1,"                    \n"]]}]}]},{"timestamp":1743733894253,"editorVersion":"2.0.46","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":8577,"length1":22,"diffs":[[1,""]]}]}]},{"timestamp":1743733943324,"editorVersion":"2.0.46","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":5939,"length1":85,"diffs":[[1,"            this.cornerRadius = cornerRadius\n"]]},{"start1":8577,"length1":395,"diffs":[[1,"                    \n"]]},{"start1":8599,"length1":1363,"diffs":[[1,""]]}]}]},{"timestamp":1743734378301,"editorVersion":"2.0.46","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":772,"length1":9,"diffs":[[1,""]]},{"start1":885,"length1":48,"diffs":[[1,""]]},{"start1":924,"length1":59,"diffs":[[1,""]]},{"start1":946,"length1":40,"diffs":[[1,""]]},{"start1":3754,"length1":353,"diffs":[[1,""]]},{"start1":5939,"length1":95,"diffs":[[1,"            this.cornerRadius = Math.min(cornerRadius, Math.min(size.x, size.y) / 2)\n"]]}]}]},{"timestamp":1743734965885,"editorVersion":"2.0.46","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":100,"length1":22,"diffs":[[1,""]]}]},{"type":"edited","filename":"ui.ts","patch":[{"start1":772,"length1":40,"diffs":[[1,"        \n"]]},{"start1":808,"length1":46,"diffs":[[1,""]]},{"start1":836,"length1":47,"diffs":[[1,""]]},{"start1":1109,"length1":199,"diffs":[[1,"    export class Box extends Element implements Outline, Position {\n        position: Vector2\n"]]},{"start1":4263,"length1":439,"diffs":[[1,""]]},{"start1":4270,"length1":78,"diffs":[[1,"    export class Circle extends Element implements Outline, Position {\n"]]},{"start1":6236,"length1":813,"diffs":[[1,""]]},{"start1":6448,"length1":45,"diffs":[[1,"            this.cornerRadius = Math.min(cornerRadius, Math.min(this.size.x, this.size.y) / 2)\n"]]},{"start1":6671,"length1":393,"diffs":[[1,"                    let left = this.position.x + this.cornerRadius - 1\n                    let right = this.position.x + this.size.x - this.cornerRadius\n                    let top = this.position.y + this.cornerRadius - 1\n                    let bottom = this.position.y + this.size.y - this.cornerRadius\n"]]},{"start1":7016,"length1":336,"diffs":[[1,"                        ctx.fillCircle(left, top, this.cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, top, this.cornerRadius, this.borderColor)\n                        ctx.fillCircle(left, bottom, this.cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, bottom, this.cornerRadius, this.borderColor)\n"]]},{"start1":7583,"length1":464,"diffs":[[1,"                        ctx.fillCircle(left + this.borderWidth, top + this.borderWidth, this.cornerRadius, this.color)\n                        ctx.fillCircle(right - this.borderWidth, top + this.borderWidth, this.cornerRadius, this.color)\n                        ctx.fillCircle(left + this.borderWidth, bottom - this.borderWidth, this.cornerRadius, this.color)\n                        ctx.fillCircle(right - this.borderWidth, bottom - this.borderWidth, this.cornerRadius, this.color)\n"]]},{"start1":10963,"length1":841,"diffs":[[1,""]]}]}]},{"timestamp":1743735555470,"editorVersion":"2.0.46","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":100,"length1":100,"diffs":[[1,".setPositionMethod()\r\nrb.positionMethod = UI.PositionMethod.TOP_LEFT\r\nrb.border = true\r\nrb.borderColor = game.Color.Blue\r\n"]]},{"start1":302,"length1":102,"diffs":[[1,"r.positionMethod = UI.PositionMethod.TOP_LEFT\r\nr.border = true\r\nr.borderColor = game.Color.Orange\r\n"]]}]},{"type":"edited","filename":"ui.ts","patch":[{"start1":1398,"length1":26,"diffs":[[1,"        private position: Vector2\n"]]},{"start1":8109,"length1":152,"diffs":[[1,"                    let cornerRadius = Math.min(this.cornerRadius, Math.min(this.size.x, this.size.y) / 2)\n"]]}]}]},{"timestamp":1743771360855,"editorVersion":"2.0.46","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":200,"length1":20,"diffs":[[1,""]]},{"start1":439,"length1":86,"diffs":[[1,"    rb.size.x = x\r\n    rb.size.y = y\r\n    r.size.x = x\r\n    r.size.y = y\r\n"]]},{"start1":515,"length1":88,"diffs":[[1,"    d.clear()\r\n    r.draw(d.ctx)\r\n    rb.draw(d.ctx)\r\n    d.show()\r\n"]]}]},{"type":"edited","filename":"ui.ts","patch":[{"start1":8101,"length1":86,"diffs":[[1,"                    let cornerRadius = Math.min(this.cornerRadius, (Math.min(this.size.x, this.size.y) - (this.border ? this.borderWidth * 2 : 0)) / 2)\n"]]},{"start1":9125,"length1":389,"diffs":[[1,"                        ctx.fillCircle(left + this.borderWidth, top + this.borderWidth, cornerRadius, this.color)\n                        ctx.fillCircle(right - this.borderWidth, top + this.borderWidth, cornerRadius, this.color)\n                        ctx.fillCircle(left + this.borderWidth, bottom - this.borderWidth, cornerRadius, this.color)\n                        ctx.fillCircle(right - this.borderWidth, bottom - this.borderWidth, cornerRadius, this.color)\n                    \n"]]}]}]},{"timestamp":1743811963737,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":28,"length1":0,"diffs":[[1,"let rb = new UI.RoundedBox(new Vector2(0, 0), new Vector2(50, 60), 20)\r\n.setPositionMethod(UI.PositionMethod.TOP_LEFT)\r\n.setBorder(true)\r\n.setBorderColor(game.Color.Blue)\r\n.setBorderWidth(5)\r\n"]]},{"start1":222,"length1":0,"diffs":[[1,"let r = new UI.Box(new Vector2(0, 0), new Vector2(50, 60), game.Color.Green)\r\n.setPositionMethod(UI.PositionMethod.TOP_LEFT)\r\n.setBorder(true)\r\n.setBorderColor(game.Color.Orange)\r\n"]]},{"start1":404,"length1":0,"diffs":[[1,"browserEvents.onMouseMove((x: number, y: number) => {\r\n    // rb.size.x = x\r\n    // rb.size.y = y\r\n    // r.size.x = x\r\n    // r.size.y = y\r\n"]]},{"start1":547,"length1":0,"diffs":[[1,"    // d.clear()\r\n    // r.draw(d.ctx)\r\n    // rb.draw(d.ctx)\r\n    // d.show()\r\n"]]},{"start1":629,"length1":383,"diffs":[[1,"    \r\n})"]]}]},{"type":"edited","filename":"ui.ts","patch":[{"start1":88,"length1":173,"diffs":[[1,""]]},{"start1":386,"length1":209,"diffs":[[1,"    class Element {\n        parent: Element\n        children: Element[]\n        constructor() {\n"]]},{"start1":513,"length1":66,"diffs":[[1,"            this.children = []\n"]]},{"start1":554,"length1":1,"diffs":[[1,""]]},{"start1":589,"length1":127,"diffs":[[1,"        setParent(element: Element): void {\n            this.parent = element\n            element.children.push(this)\n"]]},{"start1":717,"length1":365,"diffs":[[1,""]]},{"start1":724,"length1":23,"diffs":[[1,"    interface Outline {\n"]]},{"start1":1323,"length1":64,"diffs":[[1,"    export class Box extends Element implements Outline, Position, Color {\n        position: Vector2\n        positionMethod: PositionMethod\n        size: Vector2\n\n"]]},{"start1":1659,"length1":34,"diffs":[[1,"            super()\n            this.position = position\n"]]},{"start1":1772,"length1":58,"diffs":[[1,"            this.size = size\n            this.color = game.Color.Tan\n            if (color) {\n                this.color = color\n            }\n"]]},{"start1":4132,"length1":0,"diffs":[[1,"        setPosition(position: Vector2): Box {\n            this.position = position\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Box {\n            this.positionMethod = method\n            return this\n        }\n\n        setSize(size: Vector2): Box {\n            this.size = size\n            return this\n        }\n\n"]]},{"start1":4930,"length1":67,"diffs":[[1,"    export class Circle extends Element implements Outline, Position, Color {\n        position: Vector2\n        positionMethod: PositionMethod\n        size: Vector2\n"]]},{"start1":5292,"length1":65,"diffs":[[1,"            super()\n            this.position = position\n"]]},{"start1":5438,"length1":0,"diffs":[[1,"            this.size = new Vector2(this.radius * 2, this.radius * 2)\n"]]},{"start1":5509,"length1":56,"diffs":[[1,"            this.color = game.Color.Tan\n            if (color) {\n                this.color = color\n            }\n"]]},{"start1":6904,"length1":0,"diffs":[[1,"        setPosition(position: Vector2): Circle {\n            this.position = position\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Circle {\n            this.positionMethod = method\n            return this\n        }\n\n        setSize(size: Vector2): Circle {\n            this.size = size\n            return this\n        }\n\n"]]},{"start1":8101,"length1":122,"diffs":[[1,"                    let cornerRadius = Math.min(this.cornerRadius, (this.size.x / 2))\n"]]},{"start1":9486,"length1":148,"diffs":[[1,"                            left + this.borderWidth, this.position.y + this.borderWidth,\n                            right - left - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n"]]},{"start1":9779,"length1":147,"diffs":[[1,"                            this.position.x + this.borderWidth, top + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, bottom - top - this.borderWidth * 2,\n"]]},{"start1":10033,"length1":539,"diffs":[[1,""]]},{"start1":10145,"length1":449,"diffs":[[1,"                    let left = this.position.x - this.size.x / 2 + this.cornerRadius - 1\n                    let right = this.position.x + this.size.x / 2 - this.cornerRadius\n                    let top = this.position.y - this.size.y / 2 + this.cornerRadius - 1\n                    let bottom = this.position.y + this.size.y / 2 - this.cornerRadius\n"]]},{"start1":10535,"length1":336,"diffs":[[1,"                        ctx.fillCircle(left, top, this.cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, top, this.cornerRadius, this.borderColor)\n                        ctx.fillCircle(left, bottom, this.cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, bottom, this.cornerRadius, this.borderColor)\n"]]},{"start1":11015,"length1":122,"diffs":[[1,"                        ctx.fillRect(this.position.x - this.size.x, top, this.size.x, bottom - top, this.borderColor)\n"]]},{"start1":11134,"length1":388,"diffs":[[1,"                        ctx.fillCircle(left + this.borderWidth, top + this.borderWidth, this.cornerRadius, this.color)\n                        ctx.fillCircle(right - this.borderWidth, top + this.borderWidth, this.cornerRadius, this.color)\n                        ctx.fillCircle(left + this.borderWidth, bottom - this.borderWidth, this.cornerRadius, this.color)\n                        ctx.fillCircle(right - this.borderWidth, bottom - this.borderWidth, this.cornerRadius, this.color)\n"]]},{"start1":11657,"length1":166,"diffs":[[1,"                            left + this.borderWidth, this.position.y - this.size.y + this.borderWidth,\n                            right - left - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n"]]},{"start1":11964,"length1":165,"diffs":[[1,"                            this.position.x + this.borderWidth - this.size.x, top + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, bottom - top - this.borderWidth * 2,\n"]]},{"start1":12232,"length1":30,"diffs":[[1,""]]},{"start1":12324,"length1":76,"diffs":[[1,"        setPosition(position: Vector2): RoundedBox {\n            this.position = position\n"]]},{"start1":12449,"length1":74,"diffs":[[1,"        setPositionMethod(method: PositionMethod): RoundedBox {\n            this.positionMethod = method\n"]]},{"start1":12589,"length1":88,"diffs":[[1,"        setSize(size: Vector2): RoundedBox {\n            this.size = size\n"]]},{"start1":12698,"length1":89,"diffs":[[1,"        setColor(color: color): RoundedBox {\n            this.color = color\n"]]},{"start1":12808,"length1":6,"diffs":[[1,""]]},{"start1":12809,"length1":418,"diffs":[[1,"        setBorder(on: boolean): RoundedBox {\n            this.border = on\n"]]},{"start1":12917,"length1":251,"diffs":[[1,""]]},{"start1":12918,"length1":3292,"diffs":[[1,"        setBorderColor(color: color): RoundedBox {\n            this.borderColor = color\n"]]},{"start1":13041,"length1":112,"diffs":[[1,"        setBorderWidth(width: number): RoundedBox {\n            this.borderWidth = width\n"]]},{"start1":13170,"length1":111,"diffs":[[1,""]]}]},{"type":"edited","filename":"util.ts","patch":[{"start1":128,"length1":73,"diffs":[[1,""]]}]}]},{"timestamp":1743897710801,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":16961,"length1":13,"diffs":[[1,""]]}]}]},{"timestamp":1743897782515,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":30,"length1":0,"diffs":[[1,"\r\n\r\n\r\n"]]},{"start1":108,"length1":52,"diffs":[[1,"    .setPositionMethod(UI.PositionMethod.CENTER)\r\n"]]}]},{"type":"edited","filename":"ui.ts","patch":[{"start1":4620,"length1":362,"diffs":[[1,""]]},{"start1":6821,"length1":362,"diffs":[[1,""]]},{"start1":12311,"length1":362,"diffs":[[1,""]]},{"start1":16962,"length1":391,"diffs":[[1,"        set\n"]]}]}]},{"timestamp":1743898205246,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":28,"length1":102,"diffs":[[1,"\r\nlet vb = new UI.VerticalStack(new Vector2(50, 50))\r\n"]]},{"start1":102,"length1":0,"diffs":[[1,"    .setPositionMethod(UI.PositionMethod.TOP_LEFT)\r\n"]]},{"start1":156,"length1":416,"diffs":[[1,"new UI.Circle(Vector2.zero, 10, game.Color.Tan)\r\n    .setParent(vb)\r\nnew UI.Circle(Vector2.zero, 10, game.Color.Tan)\r\n    .setParent(vb)\r\nnew UI.Circle(Vector2.zero, 10, game.Color.Tan)\r\n    .setParent(vb)\r\n"]]},{"start1":365,"length1":13,"diffs":[[1,"vb.update()\r\n"]]},{"start1":380,"length1":71,"diffs":[[1,""]]},{"start1":391,"length1":205,"diffs":[[1,"vb.draw(d.ctx)\r\nd.show()"]]}]},{"type":"edited","filename":"ui.ts","patch":[{"start1":307,"length1":28,"diffs":[[1,""]]},{"start1":396,"length1":31,"diffs":[[1,""]]},{"start1":478,"length1":129,"diffs":[[1,""]]},{"start1":552,"length1":259,"diffs":[[1,""]]},{"start1":559,"length1":813,"diffs":[[1,""]]},{"start1":1420,"length1":946,"diffs":[[1,"    interface Border {\n        border: boolean\n        setBorder(on: boolean): Element\n        borderColor: color\n        setBorderColor(color: color): Element\n        borderWidth: number\n        setBorderWidth(width: number): Element\n    }\n"]]},{"start1":1662,"length1":167,"diffs":[[1,"    interface Position {\n        position: Vector2\n        setPosition(position: Vector2): Element\n        positionMethod: PositionMethod\n        setPositionMethod(method: PositionMethod): Element\n        size: Vector2\n        setSize(size: Vector2): Element\n"]]},{"start1":1928,"length1":66,"diffs":[[1,"    interface Color {\n"]]},{"start1":1971,"length1":0,"diffs":[[1,"        setColor(color: color): Element\n    }\n"]]},{"start1":2018,"length1":0,"diffs":[[1,"    export class Box extends Element implements Border, Color {\n        color: color\n\n"]]},{"start1":2184,"length1":73,"diffs":[[1,""]]},{"start1":5420,"length1":1060,"diffs":[[1,""]]},{"start1":5427,"length1":69,"diffs":[[1,"    export class Circle extends Element implements Border, Color {\n"]]},{"start1":5619,"length1":73,"diffs":[[1,""]]},{"start1":6187,"length1":237,"diffs":[[1,"                        ctx.fillCircle(this.position.x, this.position.y, this.radius, this.borderColor)\n                        ctx.fillCircle(this.position.x, this.position.y, this.radius - this.borderWidth, this.color)\n"]]},{"start1":6437,"length1":106,"diffs":[[1,"                        ctx.fillCircle(this.position.x, this.position.y, this.radius, this.color)\n"]]},{"start1":6688,"length1":293,"diffs":[[1,"                        ctx.fillCircle(this.position.x - this.radius, this.position.y - this.radius, this.radius, this.borderColor)\n                        ctx.fillCircle(this.position.x - this.radius, this.position.y - this.radius, this.radius - this.borderWidth, this.color)\n"]]},{"start1":6994,"length1":106,"diffs":[[1,"                        ctx.fillCircle(this.position.x, this.position.y, this.radius, this.color)\n"]]},{"start1":7183,"length1":364,"diffs":[[1,"        setPosition(position: Vector2): Box {\n"]]},{"start1":7304,"length1":41,"diffs":[[1,"        setSize(size: Vector2): Box {\n"]]},{"start1":7409,"length1":60,"diffs":[[1,"        setPositionMethod(method: PositionMethod): Box {\n"]]},{"start1":7995,"length1":307,"diffs":[[1,""]]},{"start1":12942,"length1":312,"diffs":[[1,""]]},{"start1":12943,"length1":233,"diffs":[[1,""]]},{"start1":15303,"length1":45,"diffs":[[1,""]]},{"start1":16458,"length1":26,"diffs":[[1,""]]},{"start1":16756,"length1":160,"diffs":[[1,"                                child.setPosition(new Vector2(this.position.x - (this.size.x - child.size.x) / 2, this.position.y + offset))\n"]]},{"start1":17024,"length1":160,"diffs":[[1,"                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x) / 2, this.position.y + offset))\n"]]},{"start1":17293,"length1":125,"diffs":[[1,"                                child.setPosition(new Vector2(this.position.x, this.position.y + offset))\n"]]},{"start1":17467,"length1":0,"diffs":[[1,"                            offset += child.size.y\n                            offset += this.spacing\n"]]},{"start1":17595,"length1":94,"diffs":[[1,""]]},{"start1":18499,"length1":66,"diffs":[[1,""]]},{"start1":18500,"length1":3832,"diffs":[[1,""]]},{"start1":18549,"length1":24,"diffs":[[1,""]]},{"start1":18550,"length1":9,"diffs":[[1,""]]}]},{"type":"edited","filename":"util.ts","patch":[{"start1":201,"length1":211,"diffs":[[1,""]]}]}]},{"timestamp":1744379827087,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":826,"length1":84,"diffs":[[1,"                if (element instanceof Clickable && element.pointInside(position)) {\n"]]}]}]},{"timestamp":1744379855054,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":826,"length1":207,"diffs":[[1,"                if (element instanceof Clickable && element.pointInside(position) {\n                    element.onClick(position)\n"]]},{"start1":974,"length1":283,"diffs":[[1,""]]},{"start1":998,"length1":76,"diffs":[[1,""]]},{"start1":2734,"length1":209,"diffs":[[1,""]]},{"start1":2784,"length1":25,"diffs":[[1,"            let left, right, top, bottom\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    left = this.position.x\n                    right = this.position.x + this.size.x\n                    top = this.position.y\n                    bottom = this.position.y + this.size.y\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    left = this.position.x - this.size.x / 2\n                    right = this.position.x + this.size.x / 2\n                    top = this.position.y - this.size.y / 2\n                    bottom = this.position.y + this.size.y / 2\n                    break\n                }\n            }\n            return position.x >= left && position.x < right && position.y < bottom && position.y > top\n"]]},{"start1":3626,"length1":70,"diffs":[[1,"        setOnClick(onClick: (position: Vector2) => void): Box {\n"]]},{"start1":3968,"length1":0,"diffs":[[1,"        clickable: boolean\n        onClick: (position: Vector2) => void\n\n"]]},{"start1":8539,"length1":0,"diffs":[[1,"        clickable: boolean\n        onClick: (position: Vector2) => void\n"]]}]}]},{"timestamp":1744380454662,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":826,"length1":348,"diffs":[[1,"                if (element instanceof Container) {\n                    let container = element as Container\n                    for (let child of container) {\n                        \n                    }\n"]]},{"start1":1051,"length1":241,"diffs":[[1,"                if (element instanceof Clickable) {\n                    let clickable = element as Clickable\n                    if (clickable.clickable && clickable.pointInside(position)) {\n                        clickable.onClick(position)\n                    }\n"]]},{"start1":1358,"length1":0,"diffs":[[1,"        private clickedOn(element: Element, position: Vector2) {\n\n        }\n"]]},{"start1":18607,"length1":25,"diffs":[[1,""]]}]}]},{"timestamp":1744380994028,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":540,"length1":55,"diffs":[[1,""]]},{"start1":585,"length1":74,"diffs":[[1,"let b = new UI.RoundedBox(vs.position, vs.size, 10, game.Color.Red)\r\n"]]},{"start1":667,"length1":0,"diffs":[[1,"d.elements.push(b)\r\n"]]}]},{"type":"edited","filename":"ui.ts","patch":[{"start1":17893,"length1":25,"diffs":[[1,""]]},{"start1":18025,"length1":31,"diffs":[[1,""]]},{"start1":18052,"length1":281,"diffs":[[1,""]]},{"start1":18524,"length1":113,"diffs":[[1,""]]},{"start1":18648,"length1":0,"diffs":[[1,"        shape: Clickable\n"]]},{"start1":21788,"length1":0,"diffs":[[1,"        draw(ctx: Image) {\n            this.update()\n            super.draw(ctx)\n        }\n\n"]]},{"start1":22541,"length1":121,"diffs":[[1,""]]},{"start1":25737,"length1":0,"diffs":[[1,"        draw(ctx: Image) {\n            this.update()\n            super.draw(ctx)\n        }\n\n"]]},{"start1":26500,"length1":123,"diffs":[[1,""]]}]}]},{"timestamp":1744381578753,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":540,"length1":0,"diffs":[[1,"        d.clear()\r\n        d.draw()\r\n        d.show()\r\n"]]},{"start1":910,"length1":72,"diffs":[[1,""]]}]},{"type":"edited","filename":"ui.ts","patch":[{"start1":3686,"length1":1018,"diffs":[[1,""]]}]}]},{"timestamp":1744382177550,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":3686,"length1":48,"diffs":[[1,"    export class ImageElement extends Clickable {\n"]]},{"start1":4262,"length1":50,"diffs":[[1,"                        this.size.x,\n                        this.size.y,\n"]]},{"start1":4572,"length1":176,"diffs":[[1,"                        this.size.\n"]]},{"start1":4697,"length1":361,"diffs":[[1,""]]},{"start1":28010,"length1":551,"diffs":[[1,""]]}]}]},{"timestamp":1744382739991,"editorVersion":"2.0.48","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":152,"length1":126,"diffs":[[1,"new UI.Circle(Vector2.zero, 10, game.Color.Red)\r\n"]]},{"start1":223,"length1":96,"diffs":[[1,"    .setBorderColor(game.Color.LightBlue)\r\n    .setBorderWidth(3)\r\n"]]},{"start1":332,"length1":775,"diffs":[[1,"        new UI.Box(Vector2.zero, new Vector2(20, 20), game.Color.Red)\r\n            .setBorder(true)\r\n            .setBorderColor(game.Color.Green)\r\n            .setBorderWidth(2)\r\n            .setParent(vs)\r\n"]]},{"start1":548,"length1":104,"diffs":[[1,"    .setParent(vs)\r\n"]]},{"start1":570,"length1":681,"diffs":[[1,"vs.update()\r\n\r\nvs.setShape(new UI.RoundedBox(vs.position, vs.size, 10, game.Color.Red))\r\n\r\nd.clear()\r\n"]]},{"start1":693,"length1":0,"diffs":[[1,"d.draw()\r\nd.show()\r\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":220,"length1":66,"diffs":[[1,"        \"util.ts\"\n"]]}]},{"type":"edited","filename":"ui.ts","patch":[{"start1":3686,"length1":191,"diffs":[[1,""]]},{"start1":4060,"length1":118,"diffs":[[1,"                        this.position.x - this.size.x,\n                        this.position.y - this.size.y,\n"]]},{"start1":4412,"length1":48,"diffs":[[1,"                case PositionMethod.CENTER: {\n"]]},{"start1":19563,"length1":164,"diffs":[[1,"\n"]]},{"start1":20468,"length1":114,"diffs":[[1,""]]},{"start1":20935,"length1":27,"diffs":[[1,""]]},{"start1":24489,"length1":119,"diffs":[[1,""]]},{"start1":24958,"length1":27,"diffs":[[1,""]]},{"start1":28479,"length1":121,"diffs":[[1,""]]},{"start1":28534,"length1":4579,"diffs":[[1,""]]},{"start1":28587,"length1":40,"diffs":[[1,"           super.setPosition(position)\n"]]},{"start1":29030,"length1":234,"diffs":[[1,""]]}]},{"type":"added","filename":"images.g.jres","value":"{\n    \"image1\": {\n        \"data\": \"hwQIAAgAAAAA8A8AAPAPAADwDwD//////////wDwDwAA8A8AAPAPAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"plus_icon\"\n    },\n    \"image2\": {\n        \"data\": \"hwQIAAgAAAAA8A8AAPAPAADwDwAA8A8AAPAPAADwDwAA8A8AAPAPAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"minus_icon\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myImages\"\n    }\n}"},{"type":"added","filename":"images.g.ts","value":"// Auto-generated code. Do not edit.\nnamespace myImages {\n\n    helpers._registerFactory(\"image\", function(name: string) {\n        switch(helpers.stringTrim(name)) {\n            case \"image1\":\n            case \"plus_icon\":return img`\n. . . f f . . . \n. . . f f . . . \n. . . f f . . . \nf f f f f f f f \nf f f f f f f f \n. . . f f . . . \n. . . f f . . . \n. . . f f . . . \n`;\n            case \"image2\":\n            case \"minus_icon\":return img`\n. . . . . . . . \n. . . . . . . . \n. . . . . . . . \nf f f f f f f f \nf f f f f f f f \n. . . . . . . . \n. . . . . . . . \n. . . . . . . . \n`;\n        }\n        return null;\n    })\n\n    helpers._registerFactory(\"animation\", function(name: string) {\n        switch(helpers.stringTrim(name)) {\n\n        }\n        return null;\n    })\n\n    helpers._registerFactory(\"song\", function(name: string) {\n        switch(helpers.stringTrim(name)) {\n\n        }\n        return null;\n    })\n\n}\n// Auto-generated code. Do not edit.\n"}]},{"timestamp":1758053628239,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":3870,"length1":10,"diffs":[[1,""]]}]}]},{"timestamp":1758053649518,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":3754,"length1":21,"diffs":[[1,""]]},{"start1":3763,"length1":70,"diffs":[[1,"        constructor(position: Vector2, text: string) {\n"]]},{"start1":3860,"length1":87,"diffs":[[1,""]]},{"start1":3871,"length1":223,"diffs":[[1,"        \n"]]}]}]},{"timestamp":1758057454068,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":3754,"length1":9,"diffs":[[1,""]]}]}]},{"timestamp":1758057488754,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":3754,"length1":0,"diffs":[[1,"        \n"]]},{"start1":3784,"length1":25,"diffs":[[1,""]]},{"start1":4125,"length1":92,"diffs":[[1,"                    ctx.print(this.text, 0, 0, this.color)\n"]]},{"start1":4226,"length1":226,"diffs":[[1,""]]}]}]},{"timestamp":1758058086315,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":4008,"length1":30,"diffs":[[1,""]]},{"start1":4141,"length1":105,"diffs":[[1,"                    ctx.print(this.text, 0, 0, this.color, image.getFontForText(this.text))\n"]]}]}]},{"timestamp":1758139189963,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":3775,"length1":10,"diffs":[[1,"        textSize: number\n"]]}]}]},{"timestamp":1758139211246,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":3686,"length1":151,"diffs":[[1,""]]},{"start1":3775,"length1":27,"diffs":[[1,"        f\n"]]},{"start1":3993,"length1":43,"diffs":[[1,"            this.textSize = 1\n"]]},{"start1":4034,"length1":471,"diffs":[[1,""]]},{"start1":4156,"length1":96,"diffs":[[1,"                    ctx.print(this.text, 0, 0, this.color, image.scaledFont(image.font8, this.textSize))\n"]]},{"start1":4413,"length1":84,"diffs":[[1,"        setTextSize(size: number): TextElement {\n            this.textSize = size\n"]]}]}]},{"timestamp":1758139649342,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":3822,"length1":41,"diffs":[[1,"        \n"]]}]}]},{"timestamp":1758140138477,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":3822,"length1":9,"diffs":[[1,""]]}]}]},{"timestamp":1758141022302,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":3822,"length1":19,"diffs":[[1,"        \n"]]}]}]},{"timestamp":1758141024378,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":3822,"length1":18,"diffs":[[1,"        Continuie,\n"]]}]}]},{"timestamp":1758141025725,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":4736,"length1":10,"diffs":[[1,""]]}]}]},{"timestamp":1758142519705,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":4736,"length1":17,"diffs":[[1,"        \n"]]}]}]},{"timestamp":1758142521185,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":4736,"length1":54,"diffs":[[1,"        private \n"]]}]}]},{"timestamp":1758142536281,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":4767,"length1":17,"diffs":[[1,"            \n"]]}]}]},{"timestamp":1758143795671,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":4767,"length1":13,"diffs":[[1,"            for \n"]]}]}]},{"timestamp":1758143797345,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":4736,"length1":487,"diffs":[[1,"        private sizeOfText() {\n            \n"]]}]}]},{"timestamp":1758144395821,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":4736,"length1":334,"diffs":[[1,""]]},{"start1":4864,"length1":42,"diffs":[[1,"                    return new Vector2(text.length * 5, text.)\n"]]}]}]},{"timestamp":1758145003727,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":5198,"length1":54,"diffs":[[1,"                    return textGridSize()\n"]]}]}]},{"timestamp":1758145006641,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":5122,"length1":58,"diffs":[[1,""]]},{"start1":5198,"length1":98,"diffs":[[1,"                    return TextElement.textGridSize()\n"]]},{"start1":5310,"length1":99,"diffs":[[1,"                    return new Vector2(text.length * 6, )\n"]]},{"start1":5425,"length1":100,"diffs":[[1,"                    return new Vector2(text.length * 12, )\n"]]},{"start1":5516,"length1":28,"diffs":[[1,"            return Vector2.zero\n"]]}]},{"type":"edited","filename":"util.ts","patch":[{"start1":129,"length1":85,"diffs":[[1,""]]}]}]},{"timestamp":1758145310974,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":4254,"length1":13,"diffs":[[1,""]]}]}]},{"timestamp":1758148203883,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":4254,"length1":22,"diffs":[[1,"            \n"]]}]}]},{"timestamp":1758148208456,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"ui.ts","patch":[{"start1":4124,"length1":0,"diffs":[[1,"            this.text = text\n"]]},{"start1":4254,"length1":31,"diffs":[[1,"            this.size\n"]]},{"start1":6096,"length1":53,"diffs":[[1,""]]}]}]},{"timestamp":1758229035319,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":293,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"added","filename":"main.blocks","value":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"}]}],"snapshots":[{"timestamp":1743710361199,"editorVersion":"2.0.46","text":{"main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"ui\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\",\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1743716232232,"editorVersion":"2.0.46","text":{"main.ts":"let d = new UI.Display()\r\n\r\nlet rect = new UI.Box(new Vector2(80, 60), new Vector2(40, 30))\r\nrect.draw(d.ctx)\r\nlet circle = new UI.Circle(new Vector2(80, 60), 10, game.Color.Orange)\r\ncircle.border = true\r\ncircle.borderWidth = 2\r\ncircle.draw(d.ctx)\r\n\r\nd.show()","README.md":" ","assets.json":"","ui.ts":"namespace UI {\n    enum PositionMethod {\n        CENTER,\n        TOP_LEFT\n    }\n\n    export class Display {\n        ctx: Image\n        constructor() {\n            this.ctx = image.create(screen.width, screen.height)\n        }\n        clear() {\n            this.ctx.fill(game.Color.Transparent)\n        }\n        show() {\n            scene.setBackgroundImage(this.ctx)\n        }\n    }\n\n    class Element {\n        parent: Element\n        children: Element[]\n        constructor() {\n            this.parent = null\n            this.children = []\n        }\n        draw(ctx: Image): void { }\n        setParent(element: Element): void {\n            this.parent = element\n            element.children.push(this)\n        }\n    }\n\n    interface Outline {\n        border: boolean\n        borderColor: color\n        borderWidth: number\n    }\n\n    interface Position {\n        position: Vector2\n        positionMethod: PositionMethod\n        size: Vector2\n    }\n\n    export class Box extends Element implements Outline, Position {\n        position: Vector2\n        positionMethod: PositionMethod\n        size: Vector2\n\n        color: color\n\n        border: boolean\n        borderColor: color\n        borderWidth: number\n\n        constructor(position: Vector2, size: Vector2, color?: color) {\n            super()\n            this.position = position\n            this.positionMethod = PositionMethod.CENTER\n            this.size = size\n            this.color = game.Color.Tan\n            if (color) {\n                this.color = color\n            }\n            this.border = false\n            this.borderWidth = 1\n            this.borderColor = game.Color.Black\n        }\n\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    if (this.border) {\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2, this.position.y - this.size.y / 2,\n                            this.size.x, this.size.y,\n                            this.borderColor\n                        )\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2 + this.borderWidth,\n                            this.position.y - this.size.y / 2 + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2, this.position.y - this.size.y / 2,\n                            this.size.x, this.size.y,\n                            this.color\n                        )\n                    }\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    if (this.border) {\n                        ctx.fillRect(\n                            this.position.x, this.position.y,\n                            this.size.x, this.size.y,\n                            this.borderColor\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth, this.position.y + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillRect(\n                            this.position.x, this.position.y,\n                            this.size.x, this.size.y,\n                            this.color\n                        )\n                    }\n                    break\n                }\n            }\n        }\n    }\n\n    export class Circle extends Element implements Outline, Position {\n        position: Vector2\n        positionMethod: PositionMethod\n        size: Vector2\n        radius: number\n\n        color: color\n\n        border: boolean\n        borderColor: color\n        borderWidth: number\n        constructor(position: Vector2, radius: number, color?: color) {\n            super()\n            this.position = position\n            this.positionMethod = PositionMethod.CENTER\n            this.radius = radius\n            this.size = new Vector2(this.radius * 2, this.radius * 2)\n\n            this.color = game.Color.Tan\n            if (color) {\n                this.color = color\n            }\n\n            this.border = false\n            this.borderColor = game.Color.Black\n            this.borderWidth = 1\n        }\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    if (this.border) {\n                        ctx.fillCircle(this.position.x, this.position.y, this.radius, this.borderColor)\n                        ctx.fillCircle(this.position.x, this.position.y, this.radius - this.borderWidth, this.color)\n                    } else {\n                        ctx.fillCircle(this.position.x, this.position.y, this.radius, this.color)\n                    }\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    if (this.border) {\n                        ctx.fillCircle(this.position.x - this.radius, this.position.y - this.radius, this.radius, this.borderColor)\n                        ctx.fillCircle(this.position.x - this.radius, this.position.y - this.radius, this.radius - this.borderWidth, this.color)\n                    } else {\n                        ctx.fillCircle(this.position.x, this.position.y, this.radius, this.color)\n                    }\n                    break\n                }\n            }\n        }\n    }\n\n    export class RoundedBox extends Box {\n        cornerRadius: number\n        constructor(position: Vector2, size: Vector2, cornerRadius: number, color?: color) {\n            super(position, size, color)\n            this.cornerRadius = cornerRadius\n        }\n        draw(ctx: Image) {\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    let left = this.position.x + this.cornerRadius\n                    let right = this.position.x + this.size.x - this.cornerRadius\n                    let top = this.position.y + this.cornerRadius\n                    let bottom = this.position.y + this.size.y - this.cornerRadius\n                    if (this.border) {\n                        ctx.fillCircle(left, top, this.cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, top, this.cornerRadius, this.borderColor)\n                        ctx.fillCircle(left, bottom, this.cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, bottom, this.cornerRadius, this.borderColor)\n\n                        ctx.fillRect(left, this.position.y, right - left, this.size.y, this.borderColor)\n                        ctx.fillRect(this.position.x, top, this.size.x, bottom - top, this.borderColor)\n\n                        ctx.fillCircle(left + this.borderWidth, top + this.borderWidth, this.cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(left + this.borderWidth, bottom - this.borderWidth, this.cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right - this.borderWidth, top + this.borderWidth, this.cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right - this.borderWidth, bottom - this.borderWidth, this.cornerRadius - this.borderWidth, this.color)\n                    \n                        ctx.fillRect(\n                            left + this.borderWidth, this.position.y + this.borderWidth,\n                            right - left - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth, top + this.borderWidth,\n                            this.size.y - this.borderWidth * 2, bottom - top - this.borderWidth * 2,\n                            this.color\n                        )\n                    }\n                    break\n                }\n            }\n        }\n    }\n}","util.ts":"class Vector2 {\n    x: number\n    y: number\n    constructor(x: number, y: number) {\n        this.x = x\n        this.y = y\n    }\n}","pxt.json":"{\n    \"name\": \"ui\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"ui.ts\",\n        \"util.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1743771360855,"editorVersion":"2.0.46","text":{"main.ts":"let d = new UI.Display()\r\n\r\nlet rb = new UI.RoundedBox(new Vector2(0, 0), new Vector2(50, 60), 20)\r\n.setPositionMethod(UI.PositionMethod.TOP_LEFT)\r\n.setBorder(true)\r\n.setBorderColor(game.Color.Blue)\r\n\r\nlet r = new UI.Box(new Vector2(0, 0), new Vector2(50, 60), game.Color.Green)\r\n.setPositionMethod(UI.PositionMethod.TOP_LEFT)\r\n.setBorder(true)\r\n.setBorderColor(game.Color.Orange)\r\n\r\nbrowserEvents.onMouseMove((x: number, y: number) => {\r\n    rb.size.x = x\r\n    rb.size.y = y\r\n    r.size.x = x\r\n    r.size.y = y\r\n\r\n    d.clear()\r\n    r.draw(d.ctx)\r\n    rb.draw(d.ctx)\r\n    d.show()\r\n})","README.md":" ","assets.json":"","ui.ts":"namespace UI {\n    export enum PositionMethod {\n        CENTER,\n        TOP_LEFT\n    }\n\n    export class Display {\n        ctx: Image\n        constructor() {\n            this.ctx = image.create(screen.width, screen.height)\n        }\n        clear() {\n            this.ctx.fill(game.Color.Black)\n        }\n        show() {\n            scene.setBackgroundImage(this.ctx)\n        }\n    }\n\n    class Element {\n        parent: Element\n        children: Element[]\n        constructor() {\n            this.parent = null\n            this.children = []\n        }\n        draw(ctx: Image): void { }\n        setParent(element: Element): void {\n            this.parent = element\n            element.children.push(this)\n        }\n    }\n\n    interface Outline {\n        border: boolean\n        setBorder(on: boolean): Element\n        borderColor: color\n        setBorderColor(color: color): Element\n        borderWidth: number\n        setBorderWidth(width: number): Element\n    }\n\n    interface Position {\n        position: Vector2\n        setPosition(position: Vector2): Element\n        positionMethod: PositionMethod\n        setPositionMethod(method: PositionMethod): Element\n        size: Vector2\n        setSize(size: Vector2): Element\n    }\n\n    interface Color {\n        color: color\n        setColor(color: color): Element\n    }\n\n    export class Box extends Element implements Outline, Position, Color {\n        position: Vector2\n        positionMethod: PositionMethod\n        size: Vector2\n\n        color: color\n\n        border: boolean\n        borderColor: color\n        borderWidth: number\n\n        constructor(position: Vector2, size: Vector2, color?: color) {\n            super()\n            this.position = position\n            this.positionMethod = PositionMethod.CENTER\n            this.size = size\n            this.color = game.Color.Tan\n            if (color) {\n                this.color = color\n            }\n            this.border = false\n            this.borderWidth = 1\n            this.borderColor = game.Color.Black\n        }\n\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    if (this.border) {\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2, this.position.y - this.size.y / 2,\n                            this.size.x, this.size.y,\n                            this.borderColor\n                        )\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2 + this.borderWidth,\n                            this.position.y - this.size.y / 2 + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2, this.position.y - this.size.y / 2,\n                            this.size.x, this.size.y,\n                            this.color\n                        )\n                    }\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    if (this.border) {\n                        ctx.fillRect(\n                            this.position.x, this.position.y,\n                            this.size.x, this.size.y,\n                            this.borderColor\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth, this.position.y + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillRect(\n                            this.position.x, this.position.y,\n                            this.size.x, this.size.y,\n                            this.color\n                        )\n                    }\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): Box {\n            this.position = position\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Box {\n            this.positionMethod = method\n            return this\n        }\n\n        setSize(size: Vector2): Box {\n            this.size = size\n            return this\n        }\n\n        setColor(color: color): Box {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): Box {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): Box {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): Box {\n            this.borderWidth = width\n            return this\n        }\n    }\n\n    export class Circle extends Element implements Outline, Position, Color {\n        position: Vector2\n        positionMethod: PositionMethod\n        size: Vector2\n        radius: number\n\n        color: color\n\n        border: boolean\n        borderColor: color\n        borderWidth: number\n        constructor(position: Vector2, radius: number, color?: color) {\n            super()\n            this.position = position\n            this.positionMethod = PositionMethod.CENTER\n            this.radius = radius\n            this.size = new Vector2(this.radius * 2, this.radius * 2)\n\n            this.color = game.Color.Tan\n            if (color) {\n                this.color = color\n            }\n\n            this.border = false\n            this.borderColor = game.Color.Black\n            this.borderWidth = 1\n        }\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    if (this.border) {\n                        ctx.fillCircle(this.position.x, this.position.y, this.radius, this.borderColor)\n                        ctx.fillCircle(this.position.x, this.position.y, this.radius - this.borderWidth, this.color)\n                    } else {\n                        ctx.fillCircle(this.position.x, this.position.y, this.radius, this.color)\n                    }\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    if (this.border) {\n                        ctx.fillCircle(this.position.x - this.radius, this.position.y - this.radius, this.radius, this.borderColor)\n                        ctx.fillCircle(this.position.x - this.radius, this.position.y - this.radius, this.radius - this.borderWidth, this.color)\n                    } else {\n                        ctx.fillCircle(this.position.x, this.position.y, this.radius, this.color)\n                    }\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): Circle {\n            this.position = position\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Circle {\n            this.positionMethod = method\n            return this\n        }\n\n        setSize(size: Vector2): Circle {\n            this.size = size\n            return this\n        }\n\n        setColor(color: color): Circle {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): Circle {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): Circle {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): Circle {\n            this.borderWidth = width\n            return this\n        }\n    }\n\n    export class RoundedBox extends Box {\n        cornerRadius: number\n        constructor(position: Vector2, size: Vector2, cornerRadius: number, color?: color) {\n            super(position, size, color)\n            this.cornerRadius = cornerRadius\n        }\n        draw(ctx: Image) {\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    let cornerRadius = Math.min(this.cornerRadius, (Math.min(this.size.x, this.size.y) - (this.border ? this.borderWidth * 2 : 0)) / 2)\n                    let left = this.position.x + cornerRadius - 1\n                    let right = this.position.x + this.size.x - cornerRadius\n                    let top = this.position.y + cornerRadius - 1\n                    let bottom = this.position.y + this.size.y - cornerRadius\n                    if (this.border) {\n                        ctx.fillCircle(left, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.borderColor)\n\n                        ctx.fillRect(left, this.position.y, right - left, this.size.y, this.borderColor)\n                        ctx.fillRect(this.position.x, top, this.size.x, bottom - top, this.borderColor)\n\n                        ctx.fillCircle(left + this.borderWidth, top + this.borderWidth, cornerRadius, this.color)\n                        ctx.fillCircle(right - this.borderWidth, top + this.borderWidth, cornerRadius, this.color)\n                        ctx.fillCircle(left + this.borderWidth, bottom - this.borderWidth, cornerRadius, this.color)\n                        ctx.fillCircle(right - this.borderWidth, bottom - this.borderWidth, cornerRadius, this.color)\n                    \n                        ctx.fillRect(\n                            left + this.borderWidth, this.position.y + this.borderWidth,\n                            right - left - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth, top + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, bottom - top - this.borderWidth * 2,\n                            this.color\n                        )\n                    }\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    let left = this.position.x - this.size.x / 2 + this.cornerRadius - 1\n                    let right = this.position.x + this.size.x / 2 - this.cornerRadius\n                    let top = this.position.y - this.size.y / 2 + this.cornerRadius - 1\n                    let bottom = this.position.y + this.size.y / 2 - this.cornerRadius\n\n                    if (this.border) {\n                        ctx.fillCircle(left, top, this.cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, top, this.cornerRadius, this.borderColor)\n                        ctx.fillCircle(left, bottom, this.cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, bottom, this.cornerRadius, this.borderColor)\n\n                        ctx.fillRect(left, this.position.y - this.size.y / 2, right - left, this.size.y, this.borderColor)\n                        ctx.fillRect(this.position.x - this.size.x, top, this.size.x, bottom - top, this.borderColor)\n\n                        ctx.fillCircle(left + this.borderWidth, top + this.borderWidth, this.cornerRadius, this.color)\n                        ctx.fillCircle(right - this.borderWidth, top + this.borderWidth, this.cornerRadius, this.color)\n                        ctx.fillCircle(left + this.borderWidth, bottom - this.borderWidth, this.cornerRadius, this.color)\n                        ctx.fillCircle(right - this.borderWidth, bottom - this.borderWidth, this.cornerRadius, this.color)\n\n                        ctx.fillRect(\n                            left + this.borderWidth, this.position.y - this.size.y + this.borderWidth,\n                            right - left - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth - this.size.x, top + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, bottom - top - this.borderWidth * 2,\n                            this.color\n                        )\n                    }\n\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): RoundedBox {\n            this.position = position\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): RoundedBox {\n            this.positionMethod = method\n            return this\n        }\n\n        setSize(size: Vector2): RoundedBox {\n            this.size = size\n            return this\n        }\n\n        setColor(color: color): RoundedBox {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): RoundedBox {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): RoundedBox {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): RoundedBox {\n            this.borderWidth = width\n            return this\n        }\n    }\n}","util.ts":"class Vector2 {\n    x: number\n    y: number\n    constructor(x: number, y: number) {\n        this.x = x\n        this.y = y\n    }\n}","pxt.json":"{\n    \"name\": \"ui\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"browser-events\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"ui.ts\",\n        \"util.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1743811963737,"editorVersion":"2.0.46","text":{"main.ts":"let d = new UI.Display()\r\n\r\nlet rb = new UI.RoundedBox(new Vector2(0, 0), new Vector2(50, 60), 20)\r\n.setPositionMethod(UI.PositionMethod.TOP_LEFT)\r\n.setBorder(true)\r\n.setBorderColor(game.Color.Blue)\r\n\r\nlet r = new UI.Box(new Vector2(0, 0), new Vector2(50, 60), game.Color.Green)\r\n.setPositionMethod(UI.PositionMethod.TOP_LEFT)\r\n.setBorder(true)\r\n.setBorderColor(game.Color.Orange)\r\n\r\nbrowserEvents.onMouseMove((x: number, y: number) => {\r\n    rb.size.x = x\r\n    rb.size.y = y\r\n    r.size.x = x\r\n    r.size.y = y\r\n\r\n    d.clear()\r\n    r.draw(d.ctx)\r\n    rb.draw(d.ctx)\r\n    d.show()\r\n})","README.md":" ","assets.json":"","ui.ts":"namespace UI {\n    export enum PositionMethod {\n        CENTER,\n        TOP_LEFT\n    }\n\n    export class Display {\n        ctx: Image\n        constructor() {\n            this.ctx = image.create(screen.width, screen.height)\n        }\n        clear() {\n            this.ctx.fill(game.Color.Black)\n        }\n        show() {\n            scene.setBackgroundImage(this.ctx)\n        }\n    }\n\n    class Element {\n        parent: Element\n        children: Element[]\n        constructor() {\n            this.parent = null\n            this.children = []\n        }\n        draw(ctx: Image): void { }\n        setParent(element: Element): void {\n            this.parent = element\n            element.children.push(this)\n        }\n    }\n\n    interface Outline {\n        border: boolean\n        setBorder(on: boolean): Element\n        borderColor: color\n        setBorderColor(color: color): Element\n        borderWidth: number\n        setBorderWidth(width: number): Element\n    }\n\n    interface Position {\n        position: Vector2\n        setPosition(position: Vector2): Element\n        positionMethod: PositionMethod\n        setPositionMethod(method: PositionMethod): Element\n        size: Vector2\n        setSize(size: Vector2): Element\n    }\n\n    interface Color {\n        color: color\n        setColor(color: color): Element\n    }\n\n    export class Box extends Element implements Outline, Position, Color {\n        position: Vector2\n        positionMethod: PositionMethod\n        size: Vector2\n\n        color: color\n\n        border: boolean\n        borderColor: color\n        borderWidth: number\n\n        constructor(position: Vector2, size: Vector2, color?: color) {\n            super()\n            this.position = position\n            this.positionMethod = PositionMethod.CENTER\n            this.size = size\n            this.color = game.Color.Tan\n            if (color) {\n                this.color = color\n            }\n            this.border = false\n            this.borderWidth = 1\n            this.borderColor = game.Color.Black\n        }\n\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    if (this.border) {\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2, this.position.y - this.size.y / 2,\n                            this.size.x, this.size.y,\n                            this.borderColor\n                        )\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2 + this.borderWidth,\n                            this.position.y - this.size.y / 2 + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2, this.position.y - this.size.y / 2,\n                            this.size.x, this.size.y,\n                            this.color\n                        )\n                    }\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    if (this.border) {\n                        ctx.fillRect(\n                            this.position.x, this.position.y,\n                            this.size.x, this.size.y,\n                            this.borderColor\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth, this.position.y + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillRect(\n                            this.position.x, this.position.y,\n                            this.size.x, this.size.y,\n                            this.color\n                        )\n                    }\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): Box {\n            this.position = position\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Box {\n            this.positionMethod = method\n            return this\n        }\n\n        setSize(size: Vector2): Box {\n            this.size = size\n            return this\n        }\n\n        setColor(color: color): Box {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): Box {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): Box {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): Box {\n            this.borderWidth = width\n            return this\n        }\n    }\n\n    export class Circle extends Element implements Outline, Position, Color {\n        position: Vector2\n        positionMethod: PositionMethod\n        size: Vector2\n        radius: number\n\n        color: color\n\n        border: boolean\n        borderColor: color\n        borderWidth: number\n        constructor(position: Vector2, radius: number, color?: color) {\n            super()\n            this.position = position\n            this.positionMethod = PositionMethod.CENTER\n            this.radius = radius\n            this.size = new Vector2(this.radius * 2, this.radius * 2)\n\n            this.color = game.Color.Tan\n            if (color) {\n                this.color = color\n            }\n\n            this.border = false\n            this.borderColor = game.Color.Black\n            this.borderWidth = 1\n        }\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    if (this.border) {\n                        ctx.fillCircle(this.position.x, this.position.y, this.radius, this.borderColor)\n                        ctx.fillCircle(this.position.x, this.position.y, this.radius - this.borderWidth, this.color)\n                    } else {\n                        ctx.fillCircle(this.position.x, this.position.y, this.radius, this.color)\n                    }\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    if (this.border) {\n                        ctx.fillCircle(this.position.x - this.radius, this.position.y - this.radius, this.radius, this.borderColor)\n                        ctx.fillCircle(this.position.x - this.radius, this.position.y - this.radius, this.radius - this.borderWidth, this.color)\n                    } else {\n                        ctx.fillCircle(this.position.x, this.position.y, this.radius, this.color)\n                    }\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): Circle {\n            this.position = position\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Circle {\n            this.positionMethod = method\n            return this\n        }\n\n        setSize(size: Vector2): Circle {\n            this.size = size\n            return this\n        }\n\n        setColor(color: color): Circle {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): Circle {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): Circle {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): Circle {\n            this.borderWidth = width\n            return this\n        }\n    }\n\n    export class RoundedBox extends Box {\n        cornerRadius: number\n        constructor(position: Vector2, size: Vector2, cornerRadius: number, color?: color) {\n            super(position, size, color)\n            this.cornerRadius = cornerRadius\n        }\n        draw(ctx: Image) {\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    let cornerRadius = Math.min(this.cornerRadius, (Math.min(this.size.x, this.size.y) - (this.border ? this.borderWidth * 2 : 0)) / 2)\n                    let left = this.position.x + cornerRadius - 1\n                    let right = this.position.x + this.size.x - cornerRadius\n                    let top = this.position.y + cornerRadius - 1\n                    let bottom = this.position.y + this.size.y - cornerRadius\n                    if (this.border) {\n                        ctx.fillCircle(left, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.borderColor)\n\n                        ctx.fillRect(left, this.position.y, right - left, this.size.y, this.borderColor)\n                        ctx.fillRect(this.position.x, top, this.size.x, bottom - top, this.borderColor)\n\n                        ctx.fillCircle(left + this.borderWidth, top + this.borderWidth, cornerRadius, this.color)\n                        ctx.fillCircle(right - this.borderWidth, top + this.borderWidth, cornerRadius, this.color)\n                        ctx.fillCircle(left + this.borderWidth, bottom - this.borderWidth, cornerRadius, this.color)\n                        ctx.fillCircle(right - this.borderWidth, bottom - this.borderWidth, cornerRadius, this.color)\n                    \n                        ctx.fillRect(\n                            left + this.borderWidth, this.position.y + this.borderWidth,\n                            right - left - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth, top + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, bottom - top - this.borderWidth * 2,\n                            this.color\n                        )\n                    }\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    let left = this.position.x - this.size.x / 2 + this.cornerRadius - 1\n                    let right = this.position.x + this.size.x / 2 - this.cornerRadius\n                    let top = this.position.y - this.size.y / 2 + this.cornerRadius - 1\n                    let bottom = this.position.y + this.size.y / 2 - this.cornerRadius\n\n                    if (this.border) {\n                        ctx.fillCircle(left, top, this.cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, top, this.cornerRadius, this.borderColor)\n                        ctx.fillCircle(left, bottom, this.cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, bottom, this.cornerRadius, this.borderColor)\n\n                        ctx.fillRect(left, this.position.y - this.size.y / 2, right - left, this.size.y, this.borderColor)\n                        ctx.fillRect(this.position.x - this.size.x, top, this.size.x, bottom - top, this.borderColor)\n\n                        ctx.fillCircle(left + this.borderWidth, top + this.borderWidth, this.cornerRadius, this.color)\n                        ctx.fillCircle(right - this.borderWidth, top + this.borderWidth, this.cornerRadius, this.color)\n                        ctx.fillCircle(left + this.borderWidth, bottom - this.borderWidth, this.cornerRadius, this.color)\n                        ctx.fillCircle(right - this.borderWidth, bottom - this.borderWidth, this.cornerRadius, this.color)\n\n                        ctx.fillRect(\n                            left + this.borderWidth, this.position.y - this.size.y + this.borderWidth,\n                            right - left - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth - this.size.x, top + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, bottom - top - this.borderWidth * 2,\n                            this.color\n                        )\n                    }\n\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): RoundedBox {\n            this.position = position\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): RoundedBox {\n            this.positionMethod = method\n            return this\n        }\n\n        setSize(size: Vector2): RoundedBox {\n            this.size = size\n            return this\n        }\n\n        setColor(color: color): RoundedBox {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): RoundedBox {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): RoundedBox {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): RoundedBox {\n            this.borderWidth = width\n            return this\n        }\n    }\n}","util.ts":"class Vector2 {\n    x: number\n    y: number\n    constructor(x: number, y: number) {\n        this.x = x\n        this.y = y\n    }\n}","pxt.json":"{\n    \"name\": \"ui\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"browser-events\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"ui.ts\",\n        \"util.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1743897710801,"editorVersion":"2.0.48","text":{"main.ts":"let d = new UI.Display()\r\n\r\nlet rb = new UI.RoundedBox(new Vector2(0, 0), new Vector2(50, 60), 20)\r\n.setPositionMethod(UI.PositionMethod.TOP_LEFT)\r\n.setBorder(true)\r\n.setBorderColor(game.Color.Blue)\r\n.setBorderWidth(5)\r\n\r\nlet r = new UI.Box(new Vector2(0, 0), new Vector2(50, 60), game.Color.Green)\r\n.setPositionMethod(UI.PositionMethod.TOP_LEFT)\r\n.setBorder(true)\r\n.setBorderColor(game.Color.Orange)\r\n\r\nbrowserEvents.onMouseMove((x: number, y: number) => {\r\n    // rb.size.x = x\r\n    // rb.size.y = y\r\n    // r.size.x = x\r\n    // r.size.y = y\r\n\r\n    // d.clear()\r\n    // r.draw(d.ctx)\r\n    // rb.draw(d.ctx)\r\n    // d.show()\r\n\r\n    \r\n})","README.md":" ","assets.json":"","ui.ts":"namespace UI {\n    export enum PositionMethod {\n        CENTER,\n        TOP_LEFT\n    }\n\n    export class Display {\n        ctx: Image\n        constructor() {\n            this.ctx = image.create(screen.width, screen.height)\n        }\n        clear() {\n            this.ctx.fill(game.Color.Black)\n        }\n        show() {\n            scene.setBackgroundImage(this.ctx)\n        }\n    }\n\n    class Element {\n        parent: Element\n        children: Element[]\n        constructor() {\n            this.parent = null\n            this.children = []\n        }\n        draw(ctx: Image): void { }\n        setParent(element: Element): void {\n            this.parent = element\n            element.children.push(this)\n        }\n    }\n\n    interface Outline {\n        border: boolean\n        setBorder(on: boolean): Element\n        borderColor: color\n        setBorderColor(color: color): Element\n        borderWidth: number\n        setBorderWidth(width: number): Element\n    }\n\n    interface Position {\n        position: Vector2\n        setPosition(position: Vector2): Element\n        positionMethod: PositionMethod\n        setPositionMethod(method: PositionMethod): Element\n        size: Vector2\n        setSize(size: Vector2): Element\n    }\n\n    interface Color {\n        color: color\n        setColor(color: color): Element\n    }\n\n    export class Box extends Element implements Outline, Position, Color {\n        position: Vector2\n        positionMethod: PositionMethod\n        size: Vector2\n\n        color: color\n\n        border: boolean\n        borderColor: color\n        borderWidth: number\n\n        constructor(position: Vector2, size: Vector2, color?: color) {\n            super()\n            this.position = position\n            this.positionMethod = PositionMethod.CENTER\n            this.size = size\n            this.color = game.Color.Tan\n            if (color) {\n                this.color = color\n            }\n            this.border = false\n            this.borderWidth = 1\n            this.borderColor = game.Color.Black\n        }\n\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    if (this.border) {\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2, this.position.y - this.size.y / 2,\n                            this.size.x, this.size.y,\n                            this.borderColor\n                        )\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2 + this.borderWidth,\n                            this.position.y - this.size.y / 2 + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2, this.position.y - this.size.y / 2,\n                            this.size.x, this.size.y,\n                            this.color\n                        )\n                    }\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    if (this.border) {\n                        ctx.fillRect(\n                            this.position.x, this.position.y,\n                            this.size.x, this.size.y,\n                            this.borderColor\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth, this.position.y + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillRect(\n                            this.position.x, this.position.y,\n                            this.size.x, this.size.y,\n                            this.color\n                        )\n                    }\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): Box {\n            this.position = position\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Box {\n            this.positionMethod = method\n            return this\n        }\n\n        setSize(size: Vector2): Box {\n            this.size = size\n            return this\n        }\n\n        setColor(color: color): Box {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): Box {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): Box {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): Box {\n            this.borderWidth = width\n            return this\n        }\n    }\n\n    export class Circle extends Element implements Outline, Position, Color {\n        position: Vector2\n        positionMethod: PositionMethod\n        size: Vector2\n        radius: number\n\n        color: color\n\n        border: boolean\n        borderColor: color\n        borderWidth: number\n        constructor(position: Vector2, radius: number, color?: color) {\n            super()\n            this.position = position\n            this.positionMethod = PositionMethod.CENTER\n            this.radius = radius\n            this.size = new Vector2(this.radius * 2, this.radius * 2)\n\n            this.color = game.Color.Tan\n            if (color) {\n                this.color = color\n            }\n\n            this.border = false\n            this.borderColor = game.Color.Black\n            this.borderWidth = 1\n        }\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    if (this.border) {\n                        ctx.fillCircle(this.position.x, this.position.y, this.radius, this.borderColor)\n                        ctx.fillCircle(this.position.x, this.position.y, this.radius - this.borderWidth, this.color)\n                    } else {\n                        ctx.fillCircle(this.position.x, this.position.y, this.radius, this.color)\n                    }\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    if (this.border) {\n                        ctx.fillCircle(this.position.x - this.radius, this.position.y - this.radius, this.radius, this.borderColor)\n                        ctx.fillCircle(this.position.x - this.radius, this.position.y - this.radius, this.radius - this.borderWidth, this.color)\n                    } else {\n                        ctx.fillCircle(this.position.x, this.position.y, this.radius, this.color)\n                    }\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): Circle {\n            this.position = position\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Circle {\n            this.positionMethod = method\n            return this\n        }\n\n        setSize(size: Vector2): Circle {\n            this.size = size\n            return this\n        }\n\n        setColor(color: color): Circle {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): Circle {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): Circle {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): Circle {\n            this.borderWidth = width\n            return this\n        }\n    }\n\n    export class RoundedBox extends Box {\n        cornerRadius: number\n        constructor(position: Vector2, size: Vector2, cornerRadius: number, color?: color) {\n            super(position, size, color)\n            this.cornerRadius = cornerRadius\n        }\n        draw(ctx: Image) {\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    let cornerRadius = Math.min(this.cornerRadius, (this.size.x / 2))\n                    let left = this.position.x + cornerRadius - 1\n                    let right = this.position.x + this.size.x - cornerRadius\n                    let top = this.position.y + cornerRadius - 1\n                    let bottom = this.position.y + this.size.y - cornerRadius\n                    if (this.border) {\n                        ctx.fillCircle(left, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.borderColor)\n\n                        ctx.fillRect(left, this.position.y, right - left, this.size.y, this.borderColor)\n                        ctx.fillRect(this.position.x, top, this.size.x, bottom - top, this.borderColor)\n\n                        ctx.fillCircle(left, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius - this.borderWidth, this.color)\n\n                        ctx.fillRect(\n                            left + this.borderWidth, this.position.y + this.borderWidth,\n                            right - left - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth, top + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, bottom - top - this.borderWidth * 2,\n                            this.color\n                        )\n                    }\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    let left = this.position.x - this.size.x / 2 + this.cornerRadius - 1\n                    let right = this.position.x + this.size.x / 2 - this.cornerRadius\n                    let top = this.position.y - this.size.y / 2 + this.cornerRadius - 1\n                    let bottom = this.position.y + this.size.y / 2 - this.cornerRadius\n\n                    if (this.border) {\n                        ctx.fillCircle(left, top, this.cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, top, this.cornerRadius, this.borderColor)\n                        ctx.fillCircle(left, bottom, this.cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, bottom, this.cornerRadius, this.borderColor)\n\n                        ctx.fillRect(left, this.position.y - this.size.y / 2, right - left, this.size.y, this.borderColor)\n                        ctx.fillRect(this.position.x - this.size.x, top, this.size.x, bottom - top, this.borderColor)\n\n                        ctx.fillCircle(left + this.borderWidth, top + this.borderWidth, this.cornerRadius, this.color)\n                        ctx.fillCircle(right - this.borderWidth, top + this.borderWidth, this.cornerRadius, this.color)\n                        ctx.fillCircle(left + this.borderWidth, bottom - this.borderWidth, this.cornerRadius, this.color)\n                        ctx.fillCircle(right - this.borderWidth, bottom - this.borderWidth, this.cornerRadius, this.color)\n\n                        ctx.fillRect(\n                            left + this.borderWidth, this.position.y - this.size.y + this.borderWidth,\n                            right - left - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth - this.size.x, top + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, bottom - top - this.borderWidth * 2,\n                            this.color\n                        )\n                    }\n\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): RoundedBox {\n            this.position = position\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): RoundedBox {\n            this.positionMethod = method\n            return this\n        }\n\n        setSize(size: Vector2): RoundedBox {\n            this.size = size\n            return this\n        }\n\n        setColor(color: color): RoundedBox {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): RoundedBox {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): RoundedBox {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): RoundedBox {\n            this.borderWidth = width\n            return this\n        }\n    }\n}","util.ts":"class Vector2 {\n    x: number\n    y: number\n    constructor(x: number, y: number) {\n        this.x = x\n        this.y = y\n    }\n}","pxt.json":"{\n    \"name\": \"ui\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"browser-events\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"ui.ts\",\n        \"util.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1744381627898,"editorVersion":"2.0.48","text":{"main.ts":"let d = new UI.Display()\r\n\r\nlet vs = new UI.VerticalStack(new Vector2(80, 60))\r\n    .setPositionMethod(UI.PositionMethod.CENTER)\r\n    .setSpacing(5)\r\n\r\nnew UI.Circle(Vector2.zero, 10, game.Color.Red)\r\n    .setBorder(true)\r\n    .setBorderColor(game.Color.LightBlue)\r\n    .setBorderWidth(3)\r\n    .setOnClick((position: Vector2) => {\r\n        new UI.Box(Vector2.zero, new Vector2(20, 20), game.Color.Red)\r\n            .setBorder(true)\r\n            .setBorderColor(game.Color.Green)\r\n            .setBorderWidth(2)\r\n            .setParent(vs)\r\n    })\r\n    .setParent(vs)\r\n\r\nvs.update()\r\n\r\nvs.setShape(new UI.RoundedBox(vs.position, vs.size, 10, game.Color.Red))\r\n\r\nd.clear()\r\nd.elements.push(vs)\r\nd.draw()\r\nd.show()\r\n\r\nbrowserEvents.MouseLeft.onEvent(browserEvents.MouseButtonEvent.Pressed, function(x: number, y: number) {\r\n    d.clicked(new Vector2(x, y))\r\n})\r\n\r\ngame.onUpdate(() => {\r\n    d.clear()\r\n    d.draw()\r\n    d.show()\r\n})","README.md":" ","assets.json":"","ui.ts":"namespace UI {\n    export enum PositionMethod {\n        CENTER,\n        TOP_LEFT\n    }\n\n    export enum AlignmentMethodH {\n        CENTER,\n        LEFT,\n        RIGHT,\n    }\n\n    export enum AlignmentMethodV {\n        CENTER,\n        TOP,\n        BOTTOM\n    }\n\n    export class Display {\n        ctx: Image\n        elements: Element[]\n        constructor() {\n            this.ctx = image.create(screen.width, screen.height)\n            this.elements = []\n        }\n        clear() {\n            this.ctx.fill(game.Color.Black)\n        }\n        draw() {\n            for (let element of this.elements) {\n                element.draw(this.ctx)\n            }\n        }\n        show() {\n            scene.setBackgroundImage(this.ctx)\n        }\n        clicked(position: Vector2) {\n            for (let element of this.elements) {\n                this.clickedOn(element, position)\n            }\n        }\n        private clickedOn(element: Element, position: Vector2) {\n            if (element instanceof Container) {\n                let container = element as Container\n                for (let child of container.children) {\n                    this.clickedOn(child, position)\n                }\n            }\n            if (element instanceof Clickable) {\n                let clickable = element as Clickable\n                if (clickable.clickable && clickable.pointInside(position)) {\n                    clickable.onClick(position)\n                }\n            }\n        }\n    }\n\n    interface Border {\n        border: boolean\n        setBorder(on: boolean): Element\n        borderColor: color\n        setBorderColor(color: color): Element\n        borderWidth: number\n        setBorderWidth(width: number): Element\n    }\n\n    interface Position {\n        position: Vector2\n        setPosition(position: Vector2): Element\n        positionMethod: PositionMethod\n        setPositionMethod(method: PositionMethod): Element\n        size: Vector2\n        setSize(size: Vector2): Element\n    }\n\n    interface Color {\n        color: color\n        setColor(color: color): Element\n    }\n\n    interface Click {\n        clickable: boolean\n        pointInside(position: Vector2): boolean\n        onClick: (position: Vector2) => void\n        setOnClick(onClick: (position: Vector2) => void): Element\n    }\n\n    class Element implements Position {\n        parent: Container\n        position: Vector2\n        size: Vector2\n        positionMethod: PositionMethod\n        constructor(position: Vector2, size: Vector2) {\n            this.parent = null\n            this.position = position\n            this.size = size\n        }\n\n        draw(ctx: Image): void { }\n\n        setParent(container: Container): void {\n            this.parent = container\n            container.children.push(this)\n        }\n\n        setPosition(position: Vector2): Element {\n            this.position = position\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Element {\n            this.positionMethod = method\n            return this\n        }\n\n        setSize(size: Vector2): Element {\n            this.size = size\n            return this\n        }\n    }\n\n    class Clickable extends Element implements Click {\n        clickable: boolean\n        onClick: (position: Vector2) => void\n\n        constructor(position: Vector2, size: Vector2) {\n            super(position, size)\n            this.clickable = false\n        }\n\n        pointInside(position: Vector2): boolean {\n            return false\n        }\n\n        setOnClick(onClick: (position: Vector2) => void): Clickable {\n            this.onClick = onClick\n            this.clickable = true\n            return this\n        }\n    }\n\n    export class Box extends Clickable implements Border, Color {\n        color: color\n\n        border: boolean\n        borderColor: color\n        borderWidth: number\n\n        constructor(position: Vector2, size: Vector2, color?: color) {\n            super(position, size)\n            this.positionMethod = PositionMethod.CENTER\n\n            this.color = color ? color : game.Color.Tan\n\n            this.border = false\n            this.borderWidth = 1\n            this.borderColor = game.Color.Black\n        }\n\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    if (this.border) {\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2, this.position.y - this.size.y / 2,\n                            this.size.x, this.size.y,\n                            this.borderColor\n                        )\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2 + this.borderWidth,\n                            this.position.y - this.size.y / 2 + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2, this.position.y - this.size.y / 2,\n                            this.size.x, this.size.y,\n                            this.color\n                        )\n                    }\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    if (this.border) {\n                        ctx.fillRect(\n                            this.position.x, this.position.y,\n                            this.size.x, this.size.y,\n                            this.borderColor\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth, this.position.y + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillRect(\n                            this.position.x, this.position.y,\n                            this.size.x, this.size.y,\n                            this.color\n                        )\n                    }\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): Box {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(size: Vector2): Box {\n            super.setSize(size)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Box {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setColor(color: color): Box {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): Box {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): Box {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): Box {\n            this.borderWidth = width\n            return this\n        }\n\n        pointInside(position: Vector2): boolean {\n            let left, right, top, bottom\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    left = this.position.x\n                    right = this.position.x + this.size.x\n                    top = this.position.y\n                    bottom = this.position.y + this.size.y\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    left = this.position.x - this.size.x / 2\n                    right = this.position.x + this.size.x / 2\n                    top = this.position.y - this.size.y / 2\n                    bottom = this.position.y + this.size.y / 2\n                    break\n                }\n            }\n            return position.x >= left && position.x < right && position.y < bottom && position.y > top\n        }\n\n        setOnClick(onClick: (position: Vector2) => void): Box {\n            this.onClick = onClick\n            this.clickable = true\n            return this\n        }\n    }\n\n    export class Circle extends Clickable implements Border, Color {\n        radius: number\n\n        color: color\n\n        border: boolean\n        borderColor: color\n        borderWidth: number\n\n        constructor(position: Vector2, radius: number, color?: color) {\n            super(position, new Vector2(radius * 2, radius * 2))\n            this.positionMethod = PositionMethod.CENTER\n            this.radius = radius\n\n            this.color = color ? color : game.Color.Tan\n\n            this.border = false\n            this.borderColor = game.Color.Black\n            this.borderWidth = 1\n        }\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    if (this.border) {\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius, this.borderColor)\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius - this.borderWidth, this.color)\n                    } else {\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius, this.color)\n                    }\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    if (this.border) {\n                        this.singleCircle(ctx, this.position.x - this.radius, this.position.y - this.radius, this.radius, this.borderColor)\n                        this.singleCircle(ctx, this.position.x - this.radius, this.position.y - this.radius, this.radius - this.borderWidth, this.color)\n                    } else {\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius, this.color)\n                    }\n                    break\n                }\n            }\n        }\n\n        private singleCircle(ctx: Image, x: number, y: number, radius: number, color: number) {\n            ctx.fillCircle(x - 1, y - 1, radius, color)\n            ctx.fillCircle(x - 1, y, radius, color)\n            ctx.fillCircle(x, y - 1, radius, color)\n            ctx.fillCircle(x, y, radius, color)\n        }\n\n        setPosition(position: Vector2): Circle {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(size: Vector2): Circle {\n            super.setSize(size)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Circle {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setColor(color: color): Circle {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): Circle {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): Circle {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): Circle {\n            this.borderWidth = width\n            return this\n        }\n\n        pointInside(position: Vector2): boolean {\n            return Vector2.distance(this.position, position) < this.radius\n        }\n\n        setOnClick(onClick: (position: Vector2) => void): Circle {\n            this.onClick = onClick\n            this.clickable = true\n            return this\n        }\n    }\n\n    export class RoundedBox extends Box {\n        cornerRadius: number\n        constructor(position: Vector2, size: Vector2, cornerRadius: number, color?: color) {\n            super(position, size, color)\n            this.cornerRadius = cornerRadius\n        }\n        draw(ctx: Image) {\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    let cornerRadius = Math.min(this.cornerRadius, Math.ceil(Math.min(this.size.x, this.size.y) / 2) - 1)\n                    let left = this.position.x + cornerRadius - 1\n                    let right = this.position.x + this.size.x - cornerRadius\n                    let top = this.position.y + cornerRadius - 1\n                    let bottom = this.position.y + this.size.y - cornerRadius\n                    if (this.border) {\n                        ctx.fillCircle(left, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.borderColor)\n\n                        ctx.fillRect(left, this.position.y, right - left, this.size.y, this.borderColor)\n                        ctx.fillRect(this.position.x, top, this.size.x, bottom - top, this.borderColor)\n\n                        ctx.fillCircle(left, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius - this.borderWidth, this.color)\n\n                        ctx.fillRect(\n                            left, this.position.y + this.borderWidth,\n                            right - left, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth, top,\n                            this.size.x - this.borderWidth * 2, bottom - top,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillCircle(left, top, cornerRadius, this.color)\n                        ctx.fillCircle(right, top, cornerRadius, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.color)\n\n                        ctx.fillRect(left, this.position.y, right - left, this.size.y, this.color)\n                        ctx.fillRect(this.position.x, top, this.size.x, bottom - top, this.color)\n                    }\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    let cornerRadius = Math.min(this.cornerRadius, Math.round(Math.min(this.size.x, this.size.y) / 2))\n                    let left = this.position.x - this.size.x / 2 + cornerRadius - 1\n                    let right = this.position.x + this.size.x / 2 - cornerRadius\n                    let top = this.position.y - this.size.y / 2 + cornerRadius - 1\n                    let bottom = this.position.y + this.size.y / 2 - cornerRadius\n\n                    if (this.border) {\n                        ctx.fillCircle(left, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.borderColor)\n\n                        ctx.fillRect(left, this.position.y - this.size.y / 2, right - left, this.size.y, this.borderColor)\n                        ctx.fillRect(this.position.x - this.size.x / 2, top, this.size.x, bottom - top, this.borderColor)\n\n                        ctx.fillCircle(left, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius - this.borderWidth, this.color)\n\n                        ctx.fillRect(\n                            left, this.position.y - this.size.y / 2 + this.borderWidth,\n                            right - left, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth - this.size.x / 2, top,\n                            this.size.x - this.borderWidth * 2, bottom - top,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillCircle(left, top, cornerRadius, this.color)\n                        ctx.fillCircle(right, top, cornerRadius, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.color)\n\n                        ctx.fillRect(left, this.position.y - this.size.y / 2, right - left, this.size.y, this.color)\n                        ctx.fillRect(this.position.x - this.size.x / 2, top, this.size.x, bottom - top, this.color)\n                    }\n\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): Box {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(size: Vector2): Box {\n            super.setSize(size)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Box {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setColor(color: color): RoundedBox {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): RoundedBox {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): RoundedBox {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): RoundedBox {\n            this.borderWidth = width\n            return this\n        }\n    }\n\n    class Container extends Element {\n        children: Element[]\n        shape: Clickable\n        constructor(position: Vector2, size: Vector2) {\n            super(position, size)\n            this.children = []\n        }\n\n        update() {\n\n        }\n\n        draw(ctx: Image) {\n            this.update()\n            if (this.shape != null) {\n                this.shape.setPosition(this.position)\n                this.shape.setPositionMethod(this.positionMethod)\n                this.shape.setSize(this.size)\n                this.shape.draw(ctx)\n            }\n            for (let child of this.children) {\n                child.draw(ctx)\n            }\n        }\n\n        setPosition(position: Vector2): Container {\n            this.position = position\n            return this\n        }\n        setSize(size: Vector2): Container {\n            this.size = size\n            return this\n        }\n        setPositionMethod(method: PositionMethod): Container {\n            this.positionMethod = method\n            return this\n        }\n        setShape(shape: Clickable): Container {\n            this.shape = shape\n            return this\n        }\n    }\n\n    export class VerticalStack extends Container {\n        spacing: number\n        alignmentMethod: AlignmentMethodH\n\n        constructor(position: Vector2, children?: Element[]) {\n            super(position, Vector2.zero)\n            this.spacing = 0\n            if (children) {\n                this.children = children\n                this.update()\n            }\n            this.alignmentMethod = AlignmentMethodH.CENTER\n        }\n\n        update(): void {\n            this.size = new Vector2(0, this.spacing)\n            for (let child of this.children) {\n                this.size.y += child.size.y\n                this.size.y += this.spacing\n                this.size.x = Math.max(this.size.x, child.size.x)\n            }\n\n            this.size.x += this.spacing * 2\n\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    let offset = this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodH.LEFT: {\n                                child.setPosition(new Vector2(this.position.x, this.position.y + offset))\n                                break\n                            }\n                            case AlignmentMethodH.RIGHT: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x), this.position.y + offset))\n                                break\n                            }\n                            case AlignmentMethodH.CENTER: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x) / 2, this.position.y + offset))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    let offset = -this.size.y / 2 + this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodH.LEFT: {\n                                child.setPosition(new Vector2(this.position.x - (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodH.RIGHT: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodH.CENTER: {\n                                child.setPosition(new Vector2(this.position.x, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n            }\n        }\n\n        setSpacing(spacing: number): VerticalStack {\n            this.spacing = spacing\n            return this\n        }\n\n        setAlignmentMethod(method: AlignmentMethodH): VerticalStack {\n            this.alignmentMethod = method\n            return this\n        }\n\n        setPosition(position: Vector2): VerticalStack {\n            super.setPosition(position)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): VerticalStack {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setSize(size: Vector2): VerticalStack {\n            super.setSize(size)\n            return this\n        }\n\n        setShape(shape: Clickable): VerticalStack {\n            super.setShape(shape)\n            return this\n        }\n    }\n\n    export class HorizontalStack extends Container {\n        spacing: number\n        alignmentMethod: AlignmentMethodV\n\n        constructor(position: Vector2, children?: Element[]) {\n            super(position, Vector2.zero)\n            this.spacing = 0\n            this.alignmentMethod = AlignmentMethodV.CENTER\n            if (children) {\n                this.children = children\n                this.update()\n            }\n        }\n\n        update(): void {\n            this.size = new Vector2(this.spacing, 0)\n            for (let child of this.children) {\n                this.size.x += child.size.x\n                this.size.x += this.spacing\n                this.size.y = Math.max(this.size.y, child.size.y)\n            }\n\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    let offset = this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodV.TOP: {\n                                child.setPosition(new Vector2(this.position.x + offset, this.position.y))\n                                break\n                            }\n                            case AlignmentMethodV.BOTTOM: {\n                                child.setPosition(new Vector2(this.position.x + offset, this.position.y + (this.size.y - child.size.y)))\n                                break\n                            }\n                            case AlignmentMethodV.CENTER: {\n                                child.setPosition(new Vector2(this.position.x + offset, this.position.y + (this.size.y - child.size.y) / 2))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    let offset = -this.size.y / 2 + this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodV.TOP: {\n                                child.setPosition(new Vector2(this.position.x - (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodV.BOTTOM: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodV.CENTER: {\n                                child.setPosition(new Vector2(this.position.x, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n            }\n        }\n\n        setSpacing(spacing: number): HorizontalStack {\n            this.spacing = spacing\n            return this\n        }\n\n        setAlignmentMethod(method: AlignmentMethodV): HorizontalStack {\n            this.alignmentMethod = method\n            return this\n        }\n\n        setPosition(position: Vector2): HorizontalStack {\n            super.setPosition(position)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): HorizontalStack {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setSize(size: Vector2): HorizontalStack {\n            super.setSize(size)\n            return this\n        }\n\n        setShape(shape: Clickable): HorizontalStack {\n            super.setShape(shape)\n            return this\n        }\n    }\n\n    export class Grid extends Container {\n        spacing: number\n\n        \n    }\n}","util.ts":"class Vector2 {\n    x: number\n    y: number\n    constructor(x: number, y: number) {\n        this.x = x\n        this.y = y\n    }\n\n    static get zero(): Vector2 {\n        return new Vector2(0, 0)\n    }\n\n    static distance(a: Vector2, b: Vector2): number {\n        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2))\n    }\n\n    toString(): string {\n        return `x: ${this.x}, y: ${this.y}`\n    }\n}","pxt.json":"{\n    \"name\": \"ui\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"browser-events\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"ui.ts\",\n        \"util.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1744641767694,"editorVersion":"2.0.48","text":{"main.ts":"let d = new UI.Display()\r\n\r\nlet vs = new UI.VerticalStack(new Vector2(80, 60))\r\n    .setPositionMethod(UI.PositionMethod.CENTER)\r\n    .setSpacing(5)\r\n\r\nnew UI.Circle(Vector2.zero, 10, game.Color.Red)\r\n    .setBorder(true)\r\n    .setBorderColor(game.Color.LightBlue)\r\n    .setBorderWidth(3)\r\n    .setOnClick((position: Vector2) => {\r\n        new UI.Box(Vector2.zero, new Vector2(20, 20), game.Color.Red)\r\n            .setBorder(true)\r\n            .setBorderColor(game.Color.Green)\r\n            .setBorderWidth(2)\r\n            .setParent(vs)\r\n    })\r\n    .setParent(vs)\r\n\r\nvs.update()\r\n\r\nvs.setShape(new UI.RoundedBox(vs.position, vs.size, 10, game.Color.Red))\r\n\r\nd.clear()\r\nd.elements.push(vs)\r\nd.draw()\r\nd.show()\r\n\r\nbrowserEvents.MouseLeft.onEvent(browserEvents.MouseButtonEvent.Pressed, function(x: number, y: number) {\r\n    d.clicked(new Vector2(x, y))\r\n})\r\n\r\ngame.onUpdate(() => {\r\n    d.clear()\r\n    d.draw()\r\n    d.show()\r\n})","README.md":" ","assets.json":"","ui.ts":"namespace UI {\n    export enum PositionMethod {\n        CENTER,\n        TOP_LEFT\n    }\n\n    export enum AlignmentMethodH {\n        CENTER,\n        LEFT,\n        RIGHT,\n    }\n\n    export enum AlignmentMethodV {\n        CENTER,\n        TOP,\n        BOTTOM\n    }\n\n    export class Display {\n        ctx: Image\n        elements: Element[]\n        constructor() {\n            this.ctx = image.create(screen.width, screen.height)\n            this.elements = []\n        }\n        clear() {\n            this.ctx.fill(game.Color.Black)\n        }\n        draw() {\n            for (let element of this.elements) {\n                element.draw(this.ctx)\n            }\n        }\n        show() {\n            scene.setBackgroundImage(this.ctx)\n        }\n        clicked(position: Vector2) {\n            for (let element of this.elements) {\n                this.clickedOn(element, position)\n            }\n        }\n        private clickedOn(element: Element, position: Vector2) {\n            if (element instanceof Container) {\n                let container = element as Container\n                for (let child of container.children) {\n                    this.clickedOn(child, position)\n                }\n            }\n            if (element instanceof Clickable) {\n                let clickable = element as Clickable\n                if (clickable.clickable && clickable.pointInside(position)) {\n                    clickable.onClick(position)\n                }\n            }\n        }\n    }\n\n    interface Border {\n        border: boolean\n        setBorder(on: boolean): Element\n        borderColor: color\n        setBorderColor(color: color): Element\n        borderWidth: number\n        setBorderWidth(width: number): Element\n    }\n\n    interface Position {\n        position: Vector2\n        setPosition(position: Vector2): Element\n        positionMethod: PositionMethod\n        setPositionMethod(method: PositionMethod): Element\n        size: Vector2\n        setSize(size: Vector2): Element\n    }\n\n    interface Color {\n        color: color\n        setColor(color: color): Element\n    }\n\n    interface Click {\n        clickable: boolean\n        pointInside(position: Vector2): boolean\n        onClick: (position: Vector2) => void\n        setOnClick(onClick: (position: Vector2) => void): Element\n    }\n\n    class Element implements Position {\n        parent: Container\n        position: Vector2\n        size: Vector2\n        positionMethod: PositionMethod\n        constructor(position: Vector2, size: Vector2) {\n            this.parent = null\n            this.position = position\n            this.size = size\n        }\n\n        draw(ctx: Image): void { }\n\n        setParent(container: Container): void {\n            this.parent = container\n            container.children.push(this)\n        }\n\n        setPosition(position: Vector2): Element {\n            this.position = position\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Element {\n            this.positionMethod = method\n            return this\n        }\n\n        setSize(size: Vector2): Element {\n            this.size = size\n            return this\n        }\n    }\n\n    class Clickable extends Element implements Click {\n        clickable: boolean\n        onClick: (position: Vector2) => void\n\n        constructor(position: Vector2, size: Vector2) {\n            super(position, size)\n            this.clickable = false\n        }\n\n        pointInside(position: Vector2): boolean {\n            return false\n        }\n\n        setOnClick(onClick: (position: Vector2) => void): Clickable {\n            this.onClick = onClick\n            this.clickable = true\n            return this\n        }\n    }\n\n    export class ImageElement extends Element {\n        img: Image\n        constructor(position: Vector2, img: Image) {\n            super(position, new Vector2(img.width, img.height))\n            this.img = img\n        }\n\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    ctx.blit(\n                        this.position.x - this.size.x,\n                        this.position.y - this.size.y,\n                        this.size.x, this.size.y,\n                        this.img, 0, 0,\n                        this.size.x, this.size.y,\n                        true, false\n                    )\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    ctx.blit(\n                        this.position.x, this.position.y,\n                        this.size.x, this.size.y,\n                        this.img, 0, 0,\n                        this.size.x, this.size.y,\n                        true, false\n                    )\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): ImageElement {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(position: Vector2): ImageElement {\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): ImageElement {\n            super.setPositionMethod(method)\n            return this\n        }\n    }\n\n    export class Box extends Clickable implements Border, Color {\n        color: color\n\n        border: boolean\n        borderColor: color\n        borderWidth: number\n\n        constructor(position: Vector2, size: Vector2, color?: color) {\n            super(position, size)\n            this.positionMethod = PositionMethod.CENTER\n\n            this.color = color ? color : game.Color.Tan\n\n            this.border = false\n            this.borderWidth = 1\n            this.borderColor = game.Color.Black\n        }\n\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    if (this.border) {\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2, this.position.y - this.size.y / 2,\n                            this.size.x, this.size.y,\n                            this.borderColor\n                        )\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2 + this.borderWidth,\n                            this.position.y - this.size.y / 2 + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2, this.position.y - this.size.y / 2,\n                            this.size.x, this.size.y,\n                            this.color\n                        )\n                    }\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    if (this.border) {\n                        ctx.fillRect(\n                            this.position.x, this.position.y,\n                            this.size.x, this.size.y,\n                            this.borderColor\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth, this.position.y + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillRect(\n                            this.position.x, this.position.y,\n                            this.size.x, this.size.y,\n                            this.color\n                        )\n                    }\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): Box {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(size: Vector2): Box {\n            super.setSize(size)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Box {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setColor(color: color): Box {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): Box {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): Box {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): Box {\n            this.borderWidth = width\n            return this\n        }\n\n        pointInside(position: Vector2): boolean {\n            let left, right, top, bottom\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    left = this.position.x\n                    right = this.position.x + this.size.x\n                    top = this.position.y\n                    bottom = this.position.y + this.size.y\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    left = this.position.x - this.size.x / 2\n                    right = this.position.x + this.size.x / 2\n                    top = this.position.y - this.size.y / 2\n                    bottom = this.position.y + this.size.y / 2\n                    break\n                }\n            }\n            return position.x >= left && position.x < right && position.y < bottom && position.y > top\n        }\n\n        setOnClick(onClick: (position: Vector2) => void): Box {\n            this.onClick = onClick\n            this.clickable = true\n            return this\n        }\n    }\n\n    export class Circle extends Clickable implements Border, Color {\n        radius: number\n\n        color: color\n\n        border: boolean\n        borderColor: color\n        borderWidth: number\n\n        constructor(position: Vector2, radius: number, color?: color) {\n            super(position, new Vector2(radius * 2, radius * 2))\n            this.positionMethod = PositionMethod.CENTER\n            this.radius = radius\n\n            this.color = color ? color : game.Color.Tan\n\n            this.border = false\n            this.borderColor = game.Color.Black\n            this.borderWidth = 1\n        }\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    if (this.border) {\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius, this.borderColor)\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius - this.borderWidth, this.color)\n                    } else {\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius, this.color)\n                    }\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    if (this.border) {\n                        this.singleCircle(ctx, this.position.x - this.radius, this.position.y - this.radius, this.radius, this.borderColor)\n                        this.singleCircle(ctx, this.position.x - this.radius, this.position.y - this.radius, this.radius - this.borderWidth, this.color)\n                    } else {\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius, this.color)\n                    }\n                    break\n                }\n            }\n        }\n\n        private singleCircle(ctx: Image, x: number, y: number, radius: number, color: number) {\n            ctx.fillCircle(x - 1, y - 1, radius, color)\n            ctx.fillCircle(x - 1, y, radius, color)\n            ctx.fillCircle(x, y - 1, radius, color)\n            ctx.fillCircle(x, y, radius, color)\n        }\n\n        setPosition(position: Vector2): Circle {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(size: Vector2): Circle {\n            super.setSize(size)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Circle {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setColor(color: color): Circle {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): Circle {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): Circle {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): Circle {\n            this.borderWidth = width\n            return this\n        }\n\n        pointInside(position: Vector2): boolean {\n            return Vector2.distance(this.position, position) < this.radius\n        }\n\n        setOnClick(onClick: (position: Vector2) => void): Circle {\n            this.onClick = onClick\n            this.clickable = true\n            return this\n        }\n    }\n\n    export class RoundedBox extends Box {\n        cornerRadius: number\n        constructor(position: Vector2, size: Vector2, cornerRadius: number, color?: color) {\n            super(position, size, color)\n            this.cornerRadius = cornerRadius\n        }\n        draw(ctx: Image) {\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    let cornerRadius = Math.min(this.cornerRadius, Math.ceil(Math.min(this.size.x, this.size.y) / 2) - 1)\n                    let left = this.position.x + cornerRadius - 1\n                    let right = this.position.x + this.size.x - cornerRadius\n                    let top = this.position.y + cornerRadius - 1\n                    let bottom = this.position.y + this.size.y - cornerRadius\n                    if (this.border) {\n                        ctx.fillCircle(left, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.borderColor)\n\n                        ctx.fillRect(left, this.position.y, right - left, this.size.y, this.borderColor)\n                        ctx.fillRect(this.position.x, top, this.size.x, bottom - top, this.borderColor)\n\n                        ctx.fillCircle(left, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius - this.borderWidth, this.color)\n\n                        ctx.fillRect(\n                            left, this.position.y + this.borderWidth,\n                            right - left, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth, top,\n                            this.size.x - this.borderWidth * 2, bottom - top,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillCircle(left, top, cornerRadius, this.color)\n                        ctx.fillCircle(right, top, cornerRadius, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.color)\n\n                        ctx.fillRect(left, this.position.y, right - left, this.size.y, this.color)\n                        ctx.fillRect(this.position.x, top, this.size.x, bottom - top, this.color)\n                    }\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    let cornerRadius = Math.min(this.cornerRadius, Math.round(Math.min(this.size.x, this.size.y) / 2))\n                    let left = this.position.x - this.size.x / 2 + cornerRadius - 1\n                    let right = this.position.x + this.size.x / 2 - cornerRadius\n                    let top = this.position.y - this.size.y / 2 + cornerRadius - 1\n                    let bottom = this.position.y + this.size.y / 2 - cornerRadius\n\n                    if (this.border) {\n                        ctx.fillCircle(left, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.borderColor)\n\n                        ctx.fillRect(left, this.position.y - this.size.y / 2, right - left, this.size.y, this.borderColor)\n                        ctx.fillRect(this.position.x - this.size.x / 2, top, this.size.x, bottom - top, this.borderColor)\n\n                        ctx.fillCircle(left, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius - this.borderWidth, this.color)\n\n                        ctx.fillRect(\n                            left, this.position.y - this.size.y / 2 + this.borderWidth,\n                            right - left, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth - this.size.x / 2, top,\n                            this.size.x - this.borderWidth * 2, bottom - top,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillCircle(left, top, cornerRadius, this.color)\n                        ctx.fillCircle(right, top, cornerRadius, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.color)\n\n                        ctx.fillRect(left, this.position.y - this.size.y / 2, right - left, this.size.y, this.color)\n                        ctx.fillRect(this.position.x - this.size.x / 2, top, this.size.x, bottom - top, this.color)\n                    }\n\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): Box {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(size: Vector2): Box {\n            super.setSize(size)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Box {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setColor(color: color): RoundedBox {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): RoundedBox {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): RoundedBox {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): RoundedBox {\n            this.borderWidth = width\n            return this\n        }\n    }\n\n    class Container extends Element {\n        children: Element[]\n        shape: Clickable\n        constructor(position: Vector2, size: Vector2) {\n            super(position, size)\n            this.children = []\n        }\n\n        update() {\n\n        }\n\n        draw(ctx: Image) {\n            this.update()\n            if (this.shape != null) {\n                this.shape.setPosition(this.position)\n                this.shape.setPositionMethod(this.positionMethod)\n                this.shape.setSize(this.size)\n                this.shape.draw(ctx)\n            }\n            for (let child of this.children) {\n                child.draw(ctx)\n            }\n        }\n\n        setPosition(position: Vector2): Container {\n            this.position = position\n            return this\n        }\n        setSize(size: Vector2): Container {\n            this.size = size\n            return this\n        }\n        setPositionMethod(method: PositionMethod): Container {\n            this.positionMethod = method\n            return this\n        }\n        setShape(shape: Clickable): Container {\n            this.shape = shape\n            return this\n        }\n    }\n\n    export class VerticalStack extends Container {\n        spacing: number\n        alignmentMethod: AlignmentMethodH\n\n        constructor(position: Vector2, children?: Element[]) {\n            super(position, Vector2.zero)\n            this.spacing = 0\n            if (children) {\n                this.children = children\n                this.update()\n            }\n            this.alignmentMethod = AlignmentMethodH.CENTER\n        }\n\n        update(): void {\n            this.size = new Vector2(0, this.spacing)\n            for (let child of this.children) {\n                this.size.y += child.size.y\n                this.size.y += this.spacing\n                this.size.x = Math.max(this.size.x, child.size.x)\n            }\n\n            this.size.x += this.spacing * 2\n\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    let offset = this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodH.LEFT: {\n                                child.setPosition(new Vector2(this.position.x, this.position.y + offset))\n                                break\n                            }\n                            case AlignmentMethodH.RIGHT: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x), this.position.y + offset))\n                                break\n                            }\n                            case AlignmentMethodH.CENTER: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x) / 2, this.position.y + offset))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    let offset = -this.size.y / 2 + this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodH.LEFT: {\n                                child.setPosition(new Vector2(this.position.x - (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodH.RIGHT: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodH.CENTER: {\n                                child.setPosition(new Vector2(this.position.x, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n            }\n        }\n\n        setSpacing(spacing: number): VerticalStack {\n            this.spacing = spacing\n            return this\n        }\n\n        setAlignmentMethod(method: AlignmentMethodH): VerticalStack {\n            this.alignmentMethod = method\n            return this\n        }\n\n        setPosition(position: Vector2): VerticalStack {\n            super.setPosition(position)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): VerticalStack {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setSize(size: Vector2): VerticalStack {\n            super.setSize(size)\n            return this\n        }\n\n        setShape(shape: Clickable): VerticalStack {\n            super.setShape(shape)\n            return this\n        }\n    }\n\n    export class HorizontalStack extends Container {\n        spacing: number\n        alignmentMethod: AlignmentMethodV\n\n        constructor(position: Vector2, children?: Element[]) {\n            super(position, Vector2.zero)\n            this.spacing = 0\n            this.alignmentMethod = AlignmentMethodV.CENTER\n            if (children) {\n                this.children = children\n                this.update()\n            }\n        }\n\n        update(): void {\n            this.size = new Vector2(this.spacing, 0)\n            for (let child of this.children) {\n                this.size.x += child.size.x\n                this.size.x += this.spacing\n                this.size.y = Math.max(this.size.y, child.size.y)\n            }\n\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    let offset = this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodV.TOP: {\n                                child.setPosition(new Vector2(this.position.x + offset, this.position.y))\n                                break\n                            }\n                            case AlignmentMethodV.BOTTOM: {\n                                child.setPosition(new Vector2(this.position.x + offset, this.position.y + (this.size.y - child.size.y)))\n                                break\n                            }\n                            case AlignmentMethodV.CENTER: {\n                                child.setPosition(new Vector2(this.position.x + offset, this.position.y + (this.size.y - child.size.y) / 2))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    let offset = -this.size.y / 2 + this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodV.TOP: {\n                                child.setPosition(new Vector2(this.position.x - (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodV.BOTTOM: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodV.CENTER: {\n                                child.setPosition(new Vector2(this.position.x, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n            }\n        }\n\n        setSpacing(spacing: number): HorizontalStack {\n            this.spacing = spacing\n            return this\n        }\n\n        setAlignmentMethod(method: AlignmentMethodV): HorizontalStack {\n            this.alignmentMethod = method\n            return this\n        }\n\n        setPosition(position: Vector2): HorizontalStack {\n            super.setPosition(position)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): HorizontalStack {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setSize(size: Vector2): HorizontalStack {\n            super.setSize(size)\n            return this\n        }\n\n        setShape(shape: Clickable): HorizontalStack {\n            super.setShape(shape)\n            return this\n        }\n    }\n\n    export class DepthStack extends Container {\n        setPosition(position: Vector2): DepthStack {\n           super.setPosition(position)\n            return this\n        }\n        setSize(size: Vector2): DepthStack {\n            super.setSize(size)\n            return this\n        }\n        setPositionMethod(method: PositionMethod): DepthStack {\n            super.setPositionMethod(method)\n            return this\n        }\n        setShape(shape: Clickable): DepthStack {\n            super.setShape(shape)\n            return this\n        }\n    }\n\n    export class Grid extends Container {\n        spacing: number\n\n        \n    }\n}","util.ts":"class Vector2 {\n    x: number\n    y: number\n    constructor(x: number, y: number) {\n        this.x = x\n        this.y = y\n    }\n\n    static get zero(): Vector2 {\n        return new Vector2(0, 0)\n    }\n\n    static distance(a: Vector2, b: Vector2): number {\n        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2))\n    }\n\n    toString(): string {\n        return `x: ${this.x}, y: ${this.y}`\n    }\n}","pxt.json":"{\n    \"name\": \"ui\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"browser-events\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"ui.ts\",\n        \"util.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1744746979677,"editorVersion":"2.0.48","text":{"main.ts":"let d = new UI.Display()\r\n\r\nlet vs = new UI.VerticalStack(new Vector2(80, 60))\r\n    .setPositionMethod(UI.PositionMethod.CENTER)\r\n    .setSpacing(5)\r\n\r\nlet plus = new UI.DepthStack(Vector2.zero)\r\n    .setPositionMethod(UI.PositionMethod.CENTER)\r\nnew UI.Circle(Vector2.zero, 6)\r\n    .setBorder(true)\r\n    .setBorderWidth(1)\r\n    .setBorderColor(game.Color.Black)\r\n    .setColor(game.Color.Green)\r\n    .setOnClick((position: Vector2) => {\r\n        if (vs.children.length > 1) {\r\n            vs.children.insertAt(1, new UI.Circle(Vector2.zero, 4, game.Color.Pink))\r\n        } else {\r\n            let minus = new UI.DepthStack(Vector2.zero)\r\n                .setPositionMethod(UI.PositionMethod.CENTER)\r\n            new UI.Circle(Vector2.zero, 6)\r\n                .setBorder(true)\r\n                .setBorderWidth(1)\r\n                .setBorderColor(game.Color.Black)\r\n                .setColor(game.Color.Red)\r\n                .setOnClick((position: Vector2) => {\r\n                    vs.children.removeAt(1)\r\n                })\r\n                .setParent(minus)\r\n            new UI.ImageElement(Vector2.zero, assets.image`minus_icon`)\r\n                .setParent(minus)\r\n            vs.addChild(minus)\r\n        }\r\n    })\r\n    .setParent(plus)\r\nnew UI.ImageElement(Vector2.zero, assets.image`plus_icon`)\r\n    .setParent(plus)\r\n\r\nlet minus = new UI.DepthStack(Vector2.zero)\r\n    .setPositionMethod(UI.PositionMethod.CENTER)\r\nnew UI.Circle(Vector2.zero, 6)\r\n    .setBorder(true)\r\n    .setBorderWidth(1)\r\n    .setBorderColor(game.Color.Black)\r\n    .setColor(game.Color.Red)\r\n    .setOnClick((position: Vector2) => {\r\n        vs.children.removeAt(1)\r\n    })\r\n    .setParent(minus)\r\nnew UI.ImageElement(Vector2.zero,assets.image`minus_icon`)\r\n    .setParent(minus)\r\n    \r\nvs.addChild(plus).update()\r\nvs.addChild(minus).update()\r\nvs.setShape(\r\n    new UI.RoundedBox(vs.position, vs.size, 10, game.Color.LightBlue)\r\n        .setBorder(true)\r\n        .setBorderColor(game.Color.Purple)\r\n        .setBorderWidth(2)\r\n)\r\nd.elements.push(vs)\r\n\r\nbrowserEvents.MouseLeft.onEvent(browserEvents.MouseButtonEvent.Pressed, function(x: number, y: number) {\r\n    d.clicked(new Vector2(x, y))\r\n})\r\n\r\ngame.onUpdate(() => {\r\n    d.clear()\r\n    d.draw()\r\n    d.show()\r\n})","README.md":" ","assets.json":"","ui.ts":"namespace UI {\n    export enum PositionMethod {\n        CENTER,\n        TOP_LEFT\n    }\n\n    export enum AlignmentMethodH {\n        CENTER,\n        LEFT,\n        RIGHT,\n    }\n\n    export enum AlignmentMethodV {\n        CENTER,\n        TOP,\n        BOTTOM\n    }\n\n    export class Display {\n        ctx: Image\n        elements: Element[]\n        constructor() {\n            this.ctx = image.create(screen.width, screen.height)\n            this.elements = []\n        }\n        clear() {\n            this.ctx.fill(game.Color.Black)\n        }\n        draw() {\n            for (let element of this.elements) {\n                element.draw(this.ctx)\n            }\n        }\n        show() {\n            scene.setBackgroundImage(this.ctx)\n        }\n        clicked(position: Vector2) {\n            for (let element of this.elements) {\n                this.clickedOn(element, position)\n            }\n        }\n        private clickedOn(element: Element, position: Vector2) {\n            if (element instanceof Container) {\n                let container = element as Container\n                for (let child of container.children) {\n                    this.clickedOn(child, position)\n                }\n            }\n            if (element instanceof Clickable) {\n                let clickable = element as Clickable\n                if (clickable.clickable && clickable.pointInside(position)) {\n                    clickable.onClick(position)\n                }\n            }\n        }\n    }\n\n    interface Border {\n        border: boolean\n        setBorder(on: boolean): Element\n        borderColor: color\n        setBorderColor(color: color): Element\n        borderWidth: number\n        setBorderWidth(width: number): Element\n    }\n\n    interface Position {\n        position: Vector2\n        setPosition(position: Vector2): Element\n        positionMethod: PositionMethod\n        setPositionMethod(method: PositionMethod): Element\n        size: Vector2\n        setSize(size: Vector2): Element\n    }\n\n    interface Color {\n        color: color\n        setColor(color: color): Element\n    }\n\n    interface Click {\n        clickable: boolean\n        pointInside(position: Vector2): boolean\n        onClick: (position: Vector2) => void\n        setOnClick(onClick: (position: Vector2) => void): Element\n    }\n\n    class Element implements Position {\n        parent: Container\n        position: Vector2\n        size: Vector2\n        positionMethod: PositionMethod\n        constructor(position: Vector2, size: Vector2) {\n            this.parent = null\n            this.position = position\n            this.size = size\n        }\n\n        draw(ctx: Image): void { }\n\n        setParent(container: Container): void {\n            this.parent = container\n            container.children.push(this)\n        }\n\n        setPosition(position: Vector2): Element {\n            this.position = position\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Element {\n            this.positionMethod = method\n            return this\n        }\n\n        setSize(size: Vector2): Element {\n            this.size = size\n            return this\n        }\n    }\n\n    class Clickable extends Element implements Click {\n        clickable: boolean\n        onClick: (position: Vector2) => void\n\n        constructor(position: Vector2, size: Vector2) {\n            super(position, size)\n            this.clickable = false\n        }\n\n        pointInside(position: Vector2): boolean {\n            return false\n        }\n\n        setOnClick(onClick: (position: Vector2) => void): Clickable {\n            this.onClick = onClick\n            this.clickable = true\n            return this\n        }\n    }\n\n    export class TextElement extends Element {\n        text: string\n        \n        constructor(position: Vector2, text: string) {\n            super(position, Vector2.zero)\n        }\n    }\n\n    export class ImageElement extends Element {\n        img: Image\n        constructor(position: Vector2, img: Image) {\n            super(position, new Vector2(img.width, img.height))\n            this.img = img\n        }\n\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    ctx.blit(\n                        this.position.x - this.size.x / 2,\n                        this.position.y - this.size.y / 2,\n                        this.size.x, this.size.y,\n                        this.img, 0, 0,\n                        this.size.x, this.size.y,\n                        true, false\n                    )\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    ctx.blit(\n                        this.position.x, this.position.y,\n                        this.size.x, this.size.y,\n                        this.img, 0, 0,\n                        this.size.x, this.size.y,\n                        true, false\n                    )\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): ImageElement {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(position: Vector2): ImageElement {\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): ImageElement {\n            super.setPositionMethod(method)\n            return this\n        }\n    }\n\n    export class Box extends Clickable implements Border, Color {\n        color: color\n\n        border: boolean\n        borderColor: color\n        borderWidth: number\n\n        constructor(position: Vector2, size: Vector2, color?: color) {\n            super(position, size)\n            this.positionMethod = PositionMethod.CENTER\n\n            this.color = color ? color : game.Color.Tan\n\n            this.border = false\n            this.borderWidth = 1\n            this.borderColor = game.Color.Black\n        }\n\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    if (this.border) {\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2, this.position.y - this.size.y / 2,\n                            this.size.x, this.size.y,\n                            this.borderColor\n                        )\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2 + this.borderWidth,\n                            this.position.y - this.size.y / 2 + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2, this.position.y - this.size.y / 2,\n                            this.size.x, this.size.y,\n                            this.color\n                        )\n                    }\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    if (this.border) {\n                        ctx.fillRect(\n                            this.position.x, this.position.y,\n                            this.size.x, this.size.y,\n                            this.borderColor\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth, this.position.y + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillRect(\n                            this.position.x, this.position.y,\n                            this.size.x, this.size.y,\n                            this.color\n                        )\n                    }\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): Box {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(size: Vector2): Box {\n            super.setSize(size)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Box {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setColor(color: color): Box {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): Box {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): Box {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): Box {\n            this.borderWidth = width\n            return this\n        }\n\n        pointInside(position: Vector2): boolean {\n            let left, right, top, bottom\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    left = this.position.x\n                    right = this.position.x + this.size.x\n                    top = this.position.y\n                    bottom = this.position.y + this.size.y\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    left = this.position.x - this.size.x / 2\n                    right = this.position.x + this.size.x / 2\n                    top = this.position.y - this.size.y / 2\n                    bottom = this.position.y + this.size.y / 2\n                    break\n                }\n            }\n            return position.x >= left && position.x < right && position.y < bottom && position.y > top\n        }\n\n        setOnClick(onClick: (position: Vector2) => void): Box {\n            this.onClick = onClick\n            this.clickable = true\n            return this\n        }\n    }\n\n    export class Circle extends Clickable implements Border, Color {\n        radius: number\n\n        color: color\n\n        border: boolean\n        borderColor: color\n        borderWidth: number\n\n        constructor(position: Vector2, radius: number, color?: color) {\n            super(position, new Vector2(radius * 2, radius * 2))\n            this.positionMethod = PositionMethod.CENTER\n            this.radius = radius\n\n            this.color = color ? color : game.Color.Tan\n\n            this.border = false\n            this.borderColor = game.Color.Black\n            this.borderWidth = 1\n        }\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    if (this.border) {\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius, this.borderColor)\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius - this.borderWidth, this.color)\n                    } else {\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius, this.color)\n                    }\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    if (this.border) {\n                        this.singleCircle(ctx, this.position.x - this.radius, this.position.y - this.radius, this.radius, this.borderColor)\n                        this.singleCircle(ctx, this.position.x - this.radius, this.position.y - this.radius, this.radius - this.borderWidth, this.color)\n                    } else {\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius, this.color)\n                    }\n                    break\n                }\n            }\n        }\n\n        private singleCircle(ctx: Image, x: number, y: number, radius: number, color: number) {\n            ctx.fillCircle(x - 1, y - 1, radius, color)\n            ctx.fillCircle(x - 1, y, radius, color)\n            ctx.fillCircle(x, y - 1, radius, color)\n            ctx.fillCircle(x, y, radius, color)\n        }\n\n        setPosition(position: Vector2): Circle {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(size: Vector2): Circle {\n            super.setSize(size)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Circle {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setColor(color: color): Circle {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): Circle {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): Circle {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): Circle {\n            this.borderWidth = width\n            return this\n        }\n\n        pointInside(position: Vector2): boolean {\n            return Vector2.distance(this.position, position) < this.radius\n        }\n\n        setOnClick(onClick: (position: Vector2) => void): Circle {\n            this.onClick = onClick\n            this.clickable = true\n            return this\n        }\n    }\n\n    export class RoundedBox extends Box {\n        cornerRadius: number\n        constructor(position: Vector2, size: Vector2, cornerRadius: number, color?: color) {\n            super(position, size, color)\n            this.cornerRadius = cornerRadius\n        }\n        draw(ctx: Image) {\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    let cornerRadius = Math.min(this.cornerRadius, Math.ceil(Math.min(this.size.x, this.size.y) / 2) - 1)\n                    let left = this.position.x + cornerRadius - 1\n                    let right = this.position.x + this.size.x - cornerRadius\n                    let top = this.position.y + cornerRadius - 1\n                    let bottom = this.position.y + this.size.y - cornerRadius\n                    if (this.border) {\n                        ctx.fillCircle(left, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.borderColor)\n\n                        ctx.fillRect(left, this.position.y, right - left, this.size.y, this.borderColor)\n                        ctx.fillRect(this.position.x, top, this.size.x, bottom - top, this.borderColor)\n\n                        ctx.fillCircle(left, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius - this.borderWidth, this.color)\n\n                        ctx.fillRect(\n                            left, this.position.y + this.borderWidth,\n                            right - left, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth, top,\n                            this.size.x - this.borderWidth * 2, bottom - top,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillCircle(left, top, cornerRadius, this.color)\n                        ctx.fillCircle(right, top, cornerRadius, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.color)\n\n                        ctx.fillRect(left, this.position.y, right - left, this.size.y, this.color)\n                        ctx.fillRect(this.position.x, top, this.size.x, bottom - top, this.color)\n                    }\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    let cornerRadius = Math.min(this.cornerRadius, Math.round(Math.min(this.size.x, this.size.y) / 2))\n                    let left = this.position.x - this.size.x / 2 + cornerRadius - 1\n                    let right = this.position.x + this.size.x / 2 - cornerRadius\n                    let top = this.position.y - this.size.y / 2 + cornerRadius - 1\n                    let bottom = this.position.y + this.size.y / 2 - cornerRadius\n\n                    if (this.border) {\n                        ctx.fillCircle(left, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.borderColor)\n\n                        ctx.fillRect(left, this.position.y - this.size.y / 2, right - left, this.size.y, this.borderColor)\n                        ctx.fillRect(this.position.x - this.size.x / 2, top, this.size.x, bottom - top, this.borderColor)\n\n                        ctx.fillCircle(left, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius - this.borderWidth, this.color)\n\n                        ctx.fillRect(\n                            left, this.position.y - this.size.y / 2 + this.borderWidth,\n                            right - left, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth - this.size.x / 2, top,\n                            this.size.x - this.borderWidth * 2, bottom - top,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillCircle(left, top, cornerRadius, this.color)\n                        ctx.fillCircle(right, top, cornerRadius, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.color)\n\n                        ctx.fillRect(left, this.position.y - this.size.y / 2, right - left, this.size.y, this.color)\n                        ctx.fillRect(this.position.x - this.size.x / 2, top, this.size.x, bottom - top, this.color)\n                    }\n\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): Box {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(size: Vector2): Box {\n            super.setSize(size)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Box {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setColor(color: color): RoundedBox {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): RoundedBox {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): RoundedBox {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): RoundedBox {\n            this.borderWidth = width\n            return this\n        }\n    }\n\n    class Container extends Element {\n        children: Element[]\n        shape: Clickable\n        constructor(position: Vector2, size: Vector2) {\n            super(position, size)\n            this.children = []\n        }\n\n        update() {\n            for (let child of this.children) {\n                if (child instanceof Container) {\n                    child.update()\n                }\n            }\n        }\n\n        draw(ctx: Image) {\n            this.update()\n            if (this.shape != null) {\n                this.shape.setPosition(this.position)\n                this.shape.setPositionMethod(this.positionMethod)\n                this.shape.setSize(this.size)\n                this.shape.draw(ctx)\n            }\n            for (let child of this.children) {\n                child.draw(ctx)\n            }\n        }\n\n        setPosition(position: Vector2): Container {\n            this.position = position\n            return this\n        }\n        setSize(size: Vector2): Container {\n            this.size = size\n            return this\n        }\n        setPositionMethod(method: PositionMethod): Container {\n            this.positionMethod = method\n            return this\n        }\n        setShape(shape: Clickable): Container {\n            this.shape = shape\n            return this\n        }\n        addChild(child: Element): Container {\n            child.setParent(this)\n            return this\n        }\n    }\n\n    export class VerticalStack extends Container {\n        spacing: number\n        alignmentMethod: AlignmentMethodH\n\n        constructor(position: Vector2, children?: Element[]) {\n            super(position, Vector2.zero)\n            this.spacing = 0\n            if (children) {\n                this.children = children\n                this.update()\n            }\n            this.alignmentMethod = AlignmentMethodH.CENTER\n        }\n\n        update(): void {\n            super.update()\n            this.size = new Vector2(0, this.spacing)\n            for (let child of this.children) {\n                this.size.y += child.size.y\n                this.size.y += this.spacing\n                this.size.x = Math.max(this.size.x, child.size.x)\n            }\n\n            this.size.x += this.spacing * 2\n\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    let offset = this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodH.LEFT: {\n                                child.setPosition(new Vector2(this.position.x, this.position.y + offset))\n                                break\n                            }\n                            case AlignmentMethodH.RIGHT: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x), this.position.y + offset))\n                                break\n                            }\n                            case AlignmentMethodH.CENTER: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x) / 2, this.position.y + offset))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    let offset = -this.size.y / 2 + this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodH.LEFT: {\n                                child.setPosition(new Vector2(this.position.x - (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodH.RIGHT: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodH.CENTER: {\n                                child.setPosition(new Vector2(this.position.x, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n            }\n        }\n\n        setSpacing(spacing: number): VerticalStack {\n            this.spacing = spacing\n            return this\n        }\n\n        setAlignmentMethod(method: AlignmentMethodH): VerticalStack {\n            this.alignmentMethod = method\n            return this\n        }\n\n        setPosition(position: Vector2): VerticalStack {\n            super.setPosition(position)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): VerticalStack {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setSize(size: Vector2): VerticalStack {\n            super.setSize(size)\n            return this\n        }\n\n        setShape(shape: Clickable): VerticalStack {\n            super.setShape(shape)\n            return this\n        }\n\n        addChild(child: Element): VerticalStack {\n            super.addChild(child)\n            return this\n        }\n    }\n\n    export class HorizontalStack extends Container {\n        spacing: number\n        alignmentMethod: AlignmentMethodV\n\n        constructor(position: Vector2, children?: Element[]) {\n            super(position, Vector2.zero)\n            this.spacing = 0\n            this.alignmentMethod = AlignmentMethodV.CENTER\n            if (children) {\n                this.children = children\n                this.update()\n            }\n        }\n\n        update(): void {\n            super.update()\n            this.size = new Vector2(this.spacing, 0)\n            for (let child of this.children) {\n                this.size.x += child.size.x\n                this.size.x += this.spacing\n                this.size.y = Math.max(this.size.y, child.size.y)\n            }\n\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    let offset = this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodV.TOP: {\n                                child.setPosition(new Vector2(this.position.x + offset, this.position.y))\n                                break\n                            }\n                            case AlignmentMethodV.BOTTOM: {\n                                child.setPosition(new Vector2(this.position.x + offset, this.position.y + (this.size.y - child.size.y)))\n                                break\n                            }\n                            case AlignmentMethodV.CENTER: {\n                                child.setPosition(new Vector2(this.position.x + offset, this.position.y + (this.size.y - child.size.y) / 2))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    let offset = -this.size.y / 2 + this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodV.TOP: {\n                                child.setPosition(new Vector2(this.position.x - (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodV.BOTTOM: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodV.CENTER: {\n                                child.setPosition(new Vector2(this.position.x, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n            }\n        }\n\n        setSpacing(spacing: number): HorizontalStack {\n            this.spacing = spacing\n            return this\n        }\n\n        setAlignmentMethod(method: AlignmentMethodV): HorizontalStack {\n            this.alignmentMethod = method\n            return this\n        }\n\n        setPosition(position: Vector2): HorizontalStack {\n            super.setPosition(position)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): HorizontalStack {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setSize(size: Vector2): HorizontalStack {\n            super.setSize(size)\n            return this\n        }\n\n        setShape(shape: Clickable): HorizontalStack {\n            super.setShape(shape)\n            return this\n        }\n\n        addChild(child: Element): HorizontalStack {\n            super.addChild(child)\n            return this\n        }\n    }\n\n    export class DepthStack extends Container {\n        spacing: number\n        alignmentMethodH: AlignmentMethodH\n        alignmentMethodV: AlignmentMethodV\n        constructor(position: Vector2, children?: Element[]) {\n            super(position, Vector2.zero)\n            if (children) {\n                this.children = children\n                this.update()\n            }\n            this.alignmentMethodH = AlignmentMethodH.CENTER\n            this.alignmentMethodV = AlignmentMethodV.CENTER\n            this.spacing = 0\n        }\n        update(): void {\n            super.update()\n            this.size = Vector2.zero\n            for (let child of this.children) {\n                child.setPositionMethod(this.positionMethod)\n                this.size = new Vector2(Math.max(this.size.x, child.size.x), Math.max(this.size.y, child.size.y))\n            }\n            this.size.x += this.spacing * 2\n            this.size.y += this.spacing * 2\n            for (let child of this.children) {\n                switch (this.positionMethod) {\n                    case PositionMethod.CENTER: {\n                        let position = Vector2.zero\n                        switch (this.alignmentMethodH) {\n                            case AlignmentMethodH.LEFT: {\n                                position.x = this.position.x - (this.size.x / 2 - this.spacing) + child.size.x / 2\n                                break\n                            }\n                            case AlignmentMethodH.CENTER: {\n                                position.x = this.position.x\n                                break\n                            }\n                            case AlignmentMethodH.RIGHT: {\n                                position.x = this.position.x + (this.size.x / 2 - this.spacing) - child.size.x / 2\n                                break\n                            }\n                        }\n                        switch (this.alignmentMethodV) {\n                            case AlignmentMethodV.TOP: {\n                                position.y = this.position.y - (this.size.y / 2 - this.spacing) + child.size.y / 2\n                                break\n                            }\n                            case AlignmentMethodV.CENTER: {\n                                position.y = this.position.y\n                                break\n                            }\n                            case AlignmentMethodV.BOTTOM: {\n                                position.y = this.position.y + (this.size.y / 2 - this.spacing) - child.size.y / 2\n                                break\n                            }\n                        }\n                        child.setPosition(position)\n                        break\n                    }\n                    case PositionMethod.TOP_LEFT: {\n                        let position = Vector2.zero\n                        switch (this.alignmentMethodH) {\n                            case AlignmentMethodH.LEFT: {\n                                position.x = this.position.x - (this.size.x / 2 - this.spacing) + child.size.x / 2\n                                break\n                            }\n                            case AlignmentMethodH.CENTER: {\n                                position.x = this.position.x\n                                break\n                            }\n                            case AlignmentMethodH.RIGHT: {\n                                position.x = this.position.x + (this.size.x / 2 - this.spacing) - child.size.x / 2\n                                break\n                            }\n                        }\n                        switch (this.alignmentMethodV) {\n                            case AlignmentMethodV.TOP: {\n                                position.y = this.position.y - (this.size.y / 2 - this.spacing) + child.size.y / 2\n                                break\n                            }\n                            case AlignmentMethodV.CENTER: {\n                                position.y = this.position.y\n                                break\n                            }\n                            case AlignmentMethodV.BOTTOM: {\n                                position.y = this.position.y + (this.size.y / 2 - this.spacing) - child.size.y / 2\n                                break\n                            }\n                        }\n                        position.x += this.size.x / 2\n                        position.y += this.size.y / 2\n                        child.setPosition(position)\n                        break\n                    }\n                }\n            }\n        }\n\n        setPosition(position: Vector2): DepthStack {\n            super.setPosition(position)\n            return this\n        }\n        setSize(size: Vector2): DepthStack {\n            super.setSize(size)\n            return this\n        }\n        setPositionMethod(method: PositionMethod): DepthStack {\n            super.setPositionMethod(method)\n            return this\n        }\n        setShape(shape: Clickable): DepthStack {\n            super.setShape(shape)\n            return this\n        }\n        addChild(child: Element): DepthStack {\n            super.addChild(child)\n            return this\n        }\n        setSpacing(spacing: number): DepthStack {\n            this.spacing = spacing\n            return this\n        }\n    }\n\n    export class Grid extends Container {\n        spacing: number\n\n        \n    }\n}","util.ts":"class Vector2 {\n    x: number\n    y: number\n    constructor(x: number, y: number) {\n        this.x = x\n        this.y = y\n    }\n\n    static get zero(): Vector2 {\n        return new Vector2(0, 0)\n    }\n\n    static distance(a: Vector2, b: Vector2): number {\n        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2))\n    }\n\n    toString(): string {\n        return `x: ${this.x}, y: ${this.y}`\n    }\n}","images.g.jres":"{\n    \"image1\": {\n        \"data\": \"hwQIAAgAAAAA8A8AAPAPAADwDwD//////////wDwDwAA8A8AAPAPAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"plus_icon\"\n    },\n    \"image2\": {\n        \"data\": \"hwQIAAgAAAAA8A8AAPAPAADwDwAA8A8AAPAPAADwDwAA8A8AAPAPAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"minus_icon\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myImages\"\n    }\n}","images.g.ts":"","pxt.json":"{\n    \"name\": \"ui\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"browser-events\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"ui.ts\",\n        \"util.ts\",\n        \"images.g.jres\",\n        \"images.g.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1758057018868,"editorVersion":"2.0.56","text":{"main.ts":"let d = new UI.Display()\r\n\r\nlet vs = new UI.VerticalStack(new Vector2(80, 60))\r\n    .setPositionMethod(UI.PositionMethod.CENTER)\r\n    .setSpacing(5)\r\n\r\nlet plus = new UI.DepthStack(Vector2.zero)\r\n    .setPositionMethod(UI.PositionMethod.CENTER)\r\nnew UI.Circle(Vector2.zero, 6)\r\n    .setBorder(true)\r\n    .setBorderWidth(1)\r\n    .setBorderColor(game.Color.Black)\r\n    .setColor(game.Color.Green)\r\n    .setOnClick((position: Vector2) => {\r\n        if (vs.children.length > 1) {\r\n            vs.children.insertAt(1, new UI.Circle(Vector2.zero, 4, game.Color.Pink))\r\n        } else {\r\n            let minus = new UI.DepthStack(Vector2.zero)\r\n                .setPositionMethod(UI.PositionMethod.CENTER)\r\n            new UI.Circle(Vector2.zero, 6)\r\n                .setBorder(true)\r\n                .setBorderWidth(1)\r\n                .setBorderColor(game.Color.Black)\r\n                .setColor(game.Color.Red)\r\n                .setOnClick((position: Vector2) => {\r\n                    vs.children.removeAt(1)\r\n                })\r\n                .setParent(minus)\r\n            new UI.ImageElement(Vector2.zero, assets.image`minus_icon`)\r\n                .setParent(minus)\r\n            vs.addChild(minus)\r\n        }\r\n    })\r\n    .setParent(plus)\r\nnew UI.ImageElement(Vector2.zero, assets.image`plus_icon`)\r\n    .setParent(plus)\r\n\r\nlet minus = new UI.DepthStack(Vector2.zero)\r\n    .setPositionMethod(UI.PositionMethod.CENTER)\r\nnew UI.Circle(Vector2.zero, 6)\r\n    .setBorder(true)\r\n    .setBorderWidth(1)\r\n    .setBorderColor(game.Color.Black)\r\n    .setColor(game.Color.Red)\r\n    .setOnClick((position: Vector2) => {\r\n        vs.children.removeAt(1)\r\n    })\r\n    .setParent(minus)\r\nnew UI.ImageElement(Vector2.zero,assets.image`minus_icon`)\r\n    .setParent(minus)\r\n    \r\nvs.addChild(plus).update()\r\nvs.addChild(minus).update()\r\nvs.setShape(\r\n    new UI.RoundedBox(vs.position, vs.size, 10, game.Color.LightBlue)\r\n        .setBorder(true)\r\n        .setBorderColor(game.Color.Purple)\r\n        .setBorderWidth(2)\r\n)\r\nd.elements.push(vs)\r\n\r\nbrowserEvents.MouseLeft.onEvent(browserEvents.MouseButtonEvent.Pressed, function(x: number, y: number) {\r\n    d.clicked(new Vector2(x, y))\r\n})\r\n\r\ngame.onUpdate(() => {\r\n    d.clear()\r\n    d.draw()\r\n    d.show()\r\n})","README.md":" ","assets.json":"","ui.ts":"namespace UI {\n    export enum PositionMethod {\n        CENTER,\n        TOP_LEFT\n    }\n\n    export enum AlignmentMethodH {\n        CENTER,\n        LEFT,\n        RIGHT,\n    }\n\n    export enum AlignmentMethodV {\n        CENTER,\n        TOP,\n        BOTTOM\n    }\n\n    export class Display {\n        ctx: Image\n        elements: Element[]\n        constructor() {\n            this.ctx = image.create(screen.width, screen.height)\n            this.elements = []\n        }\n        clear() {\n            this.ctx.fill(game.Color.Black)\n        }\n        draw() {\n            for (let element of this.elements) {\n                element.draw(this.ctx)\n            }\n        }\n        show() {\n            scene.setBackgroundImage(this.ctx)\n        }\n        clicked(position: Vector2) {\n            for (let element of this.elements) {\n                this.clickedOn(element, position)\n            }\n        }\n        private clickedOn(element: Element, position: Vector2) {\n            if (element instanceof Container) {\n                let container = element as Container\n                for (let child of container.children) {\n                    this.clickedOn(child, position)\n                }\n            }\n            if (element instanceof Clickable) {\n                let clickable = element as Clickable\n                if (clickable.clickable && clickable.pointInside(position)) {\n                    clickable.onClick(position)\n                }\n            }\n        }\n    }\n\n    interface Border {\n        border: boolean\n        setBorder(on: boolean): Element\n        borderColor: color\n        setBorderColor(color: color): Element\n        borderWidth: number\n        setBorderWidth(width: number): Element\n    }\n\n    interface Position {\n        position: Vector2\n        setPosition(position: Vector2): Element\n        positionMethod: PositionMethod\n        setPositionMethod(method: PositionMethod): Element\n        size: Vector2\n        setSize(size: Vector2): Element\n    }\n\n    interface Color {\n        color: color\n        setColor(color: color): Element\n    }\n\n    interface Click {\n        clickable: boolean\n        pointInside(position: Vector2): boolean\n        onClick: (position: Vector2) => void\n        setOnClick(onClick: (position: Vector2) => void): Element\n    }\n\n    class Element implements Position {\n        parent: Container\n        position: Vector2\n        size: Vector2\n        positionMethod: PositionMethod\n        constructor(position: Vector2, size: Vector2) {\n            this.parent = null\n            this.position = position\n            this.size = size\n        }\n\n        draw(ctx: Image): void { }\n\n        setParent(container: Container): void {\n            this.parent = container\n            container.children.push(this)\n        }\n\n        setPosition(position: Vector2): Element {\n            this.position = position\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Element {\n            this.positionMethod = method\n            return this\n        }\n\n        setSize(size: Vector2): Element {\n            this.size = size\n            return this\n        }\n    }\n\n    class Clickable extends Element implements Click {\n        clickable: boolean\n        onClick: (position: Vector2) => void\n\n        constructor(position: Vector2, size: Vector2) {\n            super(position, size)\n            this.clickable = false\n        }\n\n        pointInside(position: Vector2): boolean {\n            return false\n        }\n\n        setOnClick(onClick: (position: Vector2) => void): Clickable {\n            this.onClick = onClick\n            this.clickable = true\n            return this\n        }\n    }\n\n    export class TextElement extends Element {\n        text: string\n        color: color\n        \n        constructor(position: Vector2, text: string, color?: color) {\n            super(position, Vector2.zero)\n            this.text = text\n            this.color = color ? color : game.Color.Black\n        }\n\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    ctx.print(this.text, 0, 0, this.color)\n                }\n            }\n        }\n    }\n\n    export class ImageElement extends Element {\n        img: Image\n        constructor(position: Vector2, img: Image) {\n            super(position, new Vector2(img.width, img.height))\n            this.img = img\n        }\n\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    ctx.blit(\n                        this.position.x - this.size.x / 2,\n                        this.position.y - this.size.y / 2,\n                        this.size.x, this.size.y,\n                        this.img, 0, 0,\n                        this.size.x, this.size.y,\n                        true, false\n                    )\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    ctx.blit(\n                        this.position.x, this.position.y,\n                        this.size.x, this.size.y,\n                        this.img, 0, 0,\n                        this.size.x, this.size.y,\n                        true, false\n                    )\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): ImageElement {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(position: Vector2): ImageElement {\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): ImageElement {\n            super.setPositionMethod(method)\n            return this\n        }\n    }\n\n    export class Box extends Clickable implements Border, Color {\n        color: color\n\n        border: boolean\n        borderColor: color\n        borderWidth: number\n\n        constructor(position: Vector2, size: Vector2, color?: color) {\n            super(position, size)\n            this.positionMethod = PositionMethod.CENTER\n\n            this.color = color ? color : game.Color.Tan\n\n            this.border = false\n            this.borderWidth = 1\n            this.borderColor = game.Color.Black\n        }\n\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    if (this.border) {\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2, this.position.y - this.size.y / 2,\n                            this.size.x, this.size.y,\n                            this.borderColor\n                        )\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2 + this.borderWidth,\n                            this.position.y - this.size.y / 2 + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2, this.position.y - this.size.y / 2,\n                            this.size.x, this.size.y,\n                            this.color\n                        )\n                    }\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    if (this.border) {\n                        ctx.fillRect(\n                            this.position.x, this.position.y,\n                            this.size.x, this.size.y,\n                            this.borderColor\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth, this.position.y + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillRect(\n                            this.position.x, this.position.y,\n                            this.size.x, this.size.y,\n                            this.color\n                        )\n                    }\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): Box {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(size: Vector2): Box {\n            super.setSize(size)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Box {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setColor(color: color): Box {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): Box {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): Box {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): Box {\n            this.borderWidth = width\n            return this\n        }\n\n        pointInside(position: Vector2): boolean {\n            let left, right, top, bottom\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    left = this.position.x\n                    right = this.position.x + this.size.x\n                    top = this.position.y\n                    bottom = this.position.y + this.size.y\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    left = this.position.x - this.size.x / 2\n                    right = this.position.x + this.size.x / 2\n                    top = this.position.y - this.size.y / 2\n                    bottom = this.position.y + this.size.y / 2\n                    break\n                }\n            }\n            return position.x >= left && position.x < right && position.y < bottom && position.y > top\n        }\n\n        setOnClick(onClick: (position: Vector2) => void): Box {\n            this.onClick = onClick\n            this.clickable = true\n            return this\n        }\n    }\n\n    export class Circle extends Clickable implements Border, Color {\n        radius: number\n\n        color: color\n\n        border: boolean\n        borderColor: color\n        borderWidth: number\n\n        constructor(position: Vector2, radius: number, color?: color) {\n            super(position, new Vector2(radius * 2, radius * 2))\n            this.positionMethod = PositionMethod.CENTER\n            this.radius = radius\n\n            this.color = color ? color : game.Color.Tan\n\n            this.border = false\n            this.borderColor = game.Color.Black\n            this.borderWidth = 1\n        }\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    if (this.border) {\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius, this.borderColor)\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius - this.borderWidth, this.color)\n                    } else {\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius, this.color)\n                    }\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    if (this.border) {\n                        this.singleCircle(ctx, this.position.x - this.radius, this.position.y - this.radius, this.radius, this.borderColor)\n                        this.singleCircle(ctx, this.position.x - this.radius, this.position.y - this.radius, this.radius - this.borderWidth, this.color)\n                    } else {\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius, this.color)\n                    }\n                    break\n                }\n            }\n        }\n\n        private singleCircle(ctx: Image, x: number, y: number, radius: number, color: number) {\n            ctx.fillCircle(x - 1, y - 1, radius, color)\n            ctx.fillCircle(x - 1, y, radius, color)\n            ctx.fillCircle(x, y - 1, radius, color)\n            ctx.fillCircle(x, y, radius, color)\n        }\n\n        setPosition(position: Vector2): Circle {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(size: Vector2): Circle {\n            super.setSize(size)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Circle {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setColor(color: color): Circle {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): Circle {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): Circle {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): Circle {\n            this.borderWidth = width\n            return this\n        }\n\n        pointInside(position: Vector2): boolean {\n            return Vector2.distance(this.position, position) < this.radius\n        }\n\n        setOnClick(onClick: (position: Vector2) => void): Circle {\n            this.onClick = onClick\n            this.clickable = true\n            return this\n        }\n    }\n\n    export class RoundedBox extends Box {\n        cornerRadius: number\n        constructor(position: Vector2, size: Vector2, cornerRadius: number, color?: color) {\n            super(position, size, color)\n            this.cornerRadius = cornerRadius\n        }\n        draw(ctx: Image) {\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    let cornerRadius = Math.min(this.cornerRadius, Math.ceil(Math.min(this.size.x, this.size.y) / 2) - 1)\n                    let left = this.position.x + cornerRadius - 1\n                    let right = this.position.x + this.size.x - cornerRadius\n                    let top = this.position.y + cornerRadius - 1\n                    let bottom = this.position.y + this.size.y - cornerRadius\n                    if (this.border) {\n                        ctx.fillCircle(left, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.borderColor)\n\n                        ctx.fillRect(left, this.position.y, right - left, this.size.y, this.borderColor)\n                        ctx.fillRect(this.position.x, top, this.size.x, bottom - top, this.borderColor)\n\n                        ctx.fillCircle(left, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius - this.borderWidth, this.color)\n\n                        ctx.fillRect(\n                            left, this.position.y + this.borderWidth,\n                            right - left, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth, top,\n                            this.size.x - this.borderWidth * 2, bottom - top,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillCircle(left, top, cornerRadius, this.color)\n                        ctx.fillCircle(right, top, cornerRadius, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.color)\n\n                        ctx.fillRect(left, this.position.y, right - left, this.size.y, this.color)\n                        ctx.fillRect(this.position.x, top, this.size.x, bottom - top, this.color)\n                    }\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    let cornerRadius = Math.min(this.cornerRadius, Math.round(Math.min(this.size.x, this.size.y) / 2))\n                    let left = this.position.x - this.size.x / 2 + cornerRadius - 1\n                    let right = this.position.x + this.size.x / 2 - cornerRadius\n                    let top = this.position.y - this.size.y / 2 + cornerRadius - 1\n                    let bottom = this.position.y + this.size.y / 2 - cornerRadius\n\n                    if (this.border) {\n                        ctx.fillCircle(left, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.borderColor)\n\n                        ctx.fillRect(left, this.position.y - this.size.y / 2, right - left, this.size.y, this.borderColor)\n                        ctx.fillRect(this.position.x - this.size.x / 2, top, this.size.x, bottom - top, this.borderColor)\n\n                        ctx.fillCircle(left, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius - this.borderWidth, this.color)\n\n                        ctx.fillRect(\n                            left, this.position.y - this.size.y / 2 + this.borderWidth,\n                            right - left, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth - this.size.x / 2, top,\n                            this.size.x - this.borderWidth * 2, bottom - top,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillCircle(left, top, cornerRadius, this.color)\n                        ctx.fillCircle(right, top, cornerRadius, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.color)\n\n                        ctx.fillRect(left, this.position.y - this.size.y / 2, right - left, this.size.y, this.color)\n                        ctx.fillRect(this.position.x - this.size.x / 2, top, this.size.x, bottom - top, this.color)\n                    }\n\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): Box {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(size: Vector2): Box {\n            super.setSize(size)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Box {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setColor(color: color): RoundedBox {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): RoundedBox {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): RoundedBox {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): RoundedBox {\n            this.borderWidth = width\n            return this\n        }\n    }\n\n    class Container extends Element {\n        children: Element[]\n        shape: Clickable\n        constructor(position: Vector2, size: Vector2) {\n            super(position, size)\n            this.children = []\n        }\n\n        update() {\n            for (let child of this.children) {\n                if (child instanceof Container) {\n                    child.update()\n                }\n            }\n        }\n\n        draw(ctx: Image) {\n            this.update()\n            if (this.shape != null) {\n                this.shape.setPosition(this.position)\n                this.shape.setPositionMethod(this.positionMethod)\n                this.shape.setSize(this.size)\n                this.shape.draw(ctx)\n            }\n            for (let child of this.children) {\n                child.draw(ctx)\n            }\n        }\n\n        setPosition(position: Vector2): Container {\n            this.position = position\n            return this\n        }\n        setSize(size: Vector2): Container {\n            this.size = size\n            return this\n        }\n        setPositionMethod(method: PositionMethod): Container {\n            this.positionMethod = method\n            return this\n        }\n        setShape(shape: Clickable): Container {\n            this.shape = shape\n            return this\n        }\n        addChild(child: Element): Container {\n            child.setParent(this)\n            return this\n        }\n    }\n\n    export class VerticalStack extends Container {\n        spacing: number\n        alignmentMethod: AlignmentMethodH\n\n        constructor(position: Vector2, children?: Element[]) {\n            super(position, Vector2.zero)\n            this.spacing = 0\n            if (children) {\n                this.children = children\n                this.update()\n            }\n            this.alignmentMethod = AlignmentMethodH.CENTER\n        }\n\n        update(): void {\n            super.update()\n            this.size = new Vector2(0, this.spacing)\n            for (let child of this.children) {\n                this.size.y += child.size.y\n                this.size.y += this.spacing\n                this.size.x = Math.max(this.size.x, child.size.x)\n            }\n\n            this.size.x += this.spacing * 2\n\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    let offset = this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodH.LEFT: {\n                                child.setPosition(new Vector2(this.position.x, this.position.y + offset))\n                                break\n                            }\n                            case AlignmentMethodH.RIGHT: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x), this.position.y + offset))\n                                break\n                            }\n                            case AlignmentMethodH.CENTER: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x) / 2, this.position.y + offset))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    let offset = -this.size.y / 2 + this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodH.LEFT: {\n                                child.setPosition(new Vector2(this.position.x - (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodH.RIGHT: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodH.CENTER: {\n                                child.setPosition(new Vector2(this.position.x, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n            }\n        }\n\n        setSpacing(spacing: number): VerticalStack {\n            this.spacing = spacing\n            return this\n        }\n\n        setAlignmentMethod(method: AlignmentMethodH): VerticalStack {\n            this.alignmentMethod = method\n            return this\n        }\n\n        setPosition(position: Vector2): VerticalStack {\n            super.setPosition(position)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): VerticalStack {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setSize(size: Vector2): VerticalStack {\n            super.setSize(size)\n            return this\n        }\n\n        setShape(shape: Clickable): VerticalStack {\n            super.setShape(shape)\n            return this\n        }\n\n        addChild(child: Element): VerticalStack {\n            super.addChild(child)\n            return this\n        }\n    }\n\n    export class HorizontalStack extends Container {\n        spacing: number\n        alignmentMethod: AlignmentMethodV\n\n        constructor(position: Vector2, children?: Element[]) {\n            super(position, Vector2.zero)\n            this.spacing = 0\n            this.alignmentMethod = AlignmentMethodV.CENTER\n            if (children) {\n                this.children = children\n                this.update()\n            }\n        }\n\n        update(): void {\n            super.update()\n            this.size = new Vector2(this.spacing, 0)\n            for (let child of this.children) {\n                this.size.x += child.size.x\n                this.size.x += this.spacing\n                this.size.y = Math.max(this.size.y, child.size.y)\n            }\n\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    let offset = this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodV.TOP: {\n                                child.setPosition(new Vector2(this.position.x + offset, this.position.y))\n                                break\n                            }\n                            case AlignmentMethodV.BOTTOM: {\n                                child.setPosition(new Vector2(this.position.x + offset, this.position.y + (this.size.y - child.size.y)))\n                                break\n                            }\n                            case AlignmentMethodV.CENTER: {\n                                child.setPosition(new Vector2(this.position.x + offset, this.position.y + (this.size.y - child.size.y) / 2))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    let offset = -this.size.y / 2 + this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodV.TOP: {\n                                child.setPosition(new Vector2(this.position.x - (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodV.BOTTOM: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodV.CENTER: {\n                                child.setPosition(new Vector2(this.position.x, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n            }\n        }\n\n        setSpacing(spacing: number): HorizontalStack {\n            this.spacing = spacing\n            return this\n        }\n\n        setAlignmentMethod(method: AlignmentMethodV): HorizontalStack {\n            this.alignmentMethod = method\n            return this\n        }\n\n        setPosition(position: Vector2): HorizontalStack {\n            super.setPosition(position)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): HorizontalStack {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setSize(size: Vector2): HorizontalStack {\n            super.setSize(size)\n            return this\n        }\n\n        setShape(shape: Clickable): HorizontalStack {\n            super.setShape(shape)\n            return this\n        }\n\n        addChild(child: Element): HorizontalStack {\n            super.addChild(child)\n            return this\n        }\n    }\n\n    export class DepthStack extends Container {\n        spacing: number\n        alignmentMethodH: AlignmentMethodH\n        alignmentMethodV: AlignmentMethodV\n        constructor(position: Vector2, children?: Element[]) {\n            super(position, Vector2.zero)\n            if (children) {\n                this.children = children\n                this.update()\n            }\n            this.alignmentMethodH = AlignmentMethodH.CENTER\n            this.alignmentMethodV = AlignmentMethodV.CENTER\n            this.spacing = 0\n        }\n        update(): void {\n            super.update()\n            this.size = Vector2.zero\n            for (let child of this.children) {\n                child.setPositionMethod(this.positionMethod)\n                this.size = new Vector2(Math.max(this.size.x, child.size.x), Math.max(this.size.y, child.size.y))\n            }\n            this.size.x += this.spacing * 2\n            this.size.y += this.spacing * 2\n            for (let child of this.children) {\n                switch (this.positionMethod) {\n                    case PositionMethod.CENTER: {\n                        let position = Vector2.zero\n                        switch (this.alignmentMethodH) {\n                            case AlignmentMethodH.LEFT: {\n                                position.x = this.position.x - (this.size.x / 2 - this.spacing) + child.size.x / 2\n                                break\n                            }\n                            case AlignmentMethodH.CENTER: {\n                                position.x = this.position.x\n                                break\n                            }\n                            case AlignmentMethodH.RIGHT: {\n                                position.x = this.position.x + (this.size.x / 2 - this.spacing) - child.size.x / 2\n                                break\n                            }\n                        }\n                        switch (this.alignmentMethodV) {\n                            case AlignmentMethodV.TOP: {\n                                position.y = this.position.y - (this.size.y / 2 - this.spacing) + child.size.y / 2\n                                break\n                            }\n                            case AlignmentMethodV.CENTER: {\n                                position.y = this.position.y\n                                break\n                            }\n                            case AlignmentMethodV.BOTTOM: {\n                                position.y = this.position.y + (this.size.y / 2 - this.spacing) - child.size.y / 2\n                                break\n                            }\n                        }\n                        child.setPosition(position)\n                        break\n                    }\n                    case PositionMethod.TOP_LEFT: {\n                        let position = Vector2.zero\n                        switch (this.alignmentMethodH) {\n                            case AlignmentMethodH.LEFT: {\n                                position.x = this.position.x - (this.size.x / 2 - this.spacing) + child.size.x / 2\n                                break\n                            }\n                            case AlignmentMethodH.CENTER: {\n                                position.x = this.position.x\n                                break\n                            }\n                            case AlignmentMethodH.RIGHT: {\n                                position.x = this.position.x + (this.size.x / 2 - this.spacing) - child.size.x / 2\n                                break\n                            }\n                        }\n                        switch (this.alignmentMethodV) {\n                            case AlignmentMethodV.TOP: {\n                                position.y = this.position.y - (this.size.y / 2 - this.spacing) + child.size.y / 2\n                                break\n                            }\n                            case AlignmentMethodV.CENTER: {\n                                position.y = this.position.y\n                                break\n                            }\n                            case AlignmentMethodV.BOTTOM: {\n                                position.y = this.position.y + (this.size.y / 2 - this.spacing) - child.size.y / 2\n                                break\n                            }\n                        }\n                        position.x += this.size.x / 2\n                        position.y += this.size.y / 2\n                        child.setPosition(position)\n                        break\n                    }\n                }\n            }\n        }\n\n        setPosition(position: Vector2): DepthStack {\n            super.setPosition(position)\n            return this\n        }\n        setSize(size: Vector2): DepthStack {\n            super.setSize(size)\n            return this\n        }\n        setPositionMethod(method: PositionMethod): DepthStack {\n            super.setPositionMethod(method)\n            return this\n        }\n        setShape(shape: Clickable): DepthStack {\n            super.setShape(shape)\n            return this\n        }\n        addChild(child: Element): DepthStack {\n            super.addChild(child)\n            return this\n        }\n        setSpacing(spacing: number): DepthStack {\n            this.spacing = spacing\n            return this\n        }\n    }\n\n    export class Grid extends Container {\n        spacing: number\n\n        \n    }\n}","util.ts":"class Vector2 {\n    x: number\n    y: number\n    constructor(x: number, y: number) {\n        this.x = x\n        this.y = y\n    }\n\n    static get zero(): Vector2 {\n        return new Vector2(0, 0)\n    }\n\n    static distance(a: Vector2, b: Vector2): number {\n        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2))\n    }\n\n    toString(): string {\n        return `x: ${this.x}, y: ${this.y}`\n    }\n}","images.g.jres":"{\n    \"image1\": {\n        \"data\": \"hwQIAAgAAAAA8A8AAPAPAADwDwD//////////wDwDwAA8A8AAPAPAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"plus_icon\"\n    },\n    \"image2\": {\n        \"data\": \"hwQIAAgAAAAA8A8AAPAPAADwDwAA8A8AAPAPAADwDwAA8A8AAPAPAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"minus_icon\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myImages\"\n    }\n}","images.g.ts":"","pxt.json":"{\n    \"name\": \"ui\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"browser-events\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"ui.ts\",\n        \"util.ts\",\n        \"images.g.jres\",\n        \"images.g.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1758141022302,"editorVersion":"2.0.56","text":{"main.ts":"let d = new UI.Display()\r\n\r\nlet vs = new UI.VerticalStack(new Vector2(80, 60))\r\n    .setPositionMethod(UI.PositionMethod.CENTER)\r\n    .setSpacing(5)\r\n\r\nlet plus = new UI.DepthStack(Vector2.zero)\r\n    .setPositionMethod(UI.PositionMethod.CENTER)\r\nnew UI.Circle(Vector2.zero, 6)\r\n    .setBorder(true)\r\n    .setBorderWidth(1)\r\n    .setBorderColor(game.Color.Black)\r\n    .setColor(game.Color.Green)\r\n    .setOnClick((position: Vector2) => {\r\n        if (vs.children.length > 1) {\r\n            vs.children.insertAt(1, new UI.Circle(Vector2.zero, 4, game.Color.Pink))\r\n        } else {\r\n            let minus = new UI.DepthStack(Vector2.zero)\r\n                .setPositionMethod(UI.PositionMethod.CENTER)\r\n            new UI.Circle(Vector2.zero, 6)\r\n                .setBorder(true)\r\n                .setBorderWidth(1)\r\n                .setBorderColor(game.Color.Black)\r\n                .setColor(game.Color.Red)\r\n                .setOnClick((position: Vector2) => {\r\n                    vs.children.removeAt(1)\r\n                })\r\n                .setParent(minus)\r\n            new UI.ImageElement(Vector2.zero, assets.image`minus_icon`)\r\n                .setParent(minus)\r\n            vs.addChild(minus)\r\n        }\r\n    })\r\n    .setParent(plus)\r\nnew UI.ImageElement(Vector2.zero, assets.image`plus_icon`)\r\n    .setParent(plus)\r\n\r\nlet minus = new UI.DepthStack(Vector2.zero)\r\n    .setPositionMethod(UI.PositionMethod.CENTER)\r\nnew UI.Circle(Vector2.zero, 6)\r\n    .setBorder(true)\r\n    .setBorderWidth(1)\r\n    .setBorderColor(game.Color.Black)\r\n    .setColor(game.Color.Red)\r\n    .setOnClick((position: Vector2) => {\r\n        vs.children.removeAt(1)\r\n    })\r\n    .setParent(minus)\r\nnew UI.ImageElement(Vector2.zero,assets.image`minus_icon`)\r\n    .setParent(minus)\r\n    \r\nvs.addChild(plus).update()\r\nvs.addChild(minus).update()\r\nvs.setShape(\r\n    new UI.RoundedBox(vs.position, vs.size, 10, game.Color.LightBlue)\r\n        .setBorder(true)\r\n        .setBorderColor(game.Color.Purple)\r\n        .setBorderWidth(2)\r\n)\r\nd.elements.push(vs)\r\n\r\nbrowserEvents.MouseLeft.onEvent(browserEvents.MouseButtonEvent.Pressed, function(x: number, y: number) {\r\n    d.clicked(new Vector2(x, y))\r\n})\r\n\r\ngame.onUpdate(() => {\r\n    d.clear()\r\n    d.draw()\r\n    d.show()\r\n})","README.md":" ","assets.json":"","ui.ts":"namespace UI {\n    export enum PositionMethod {\n        CENTER,\n        TOP_LEFT\n    }\n\n    export enum AlignmentMethodH {\n        CENTER,\n        LEFT,\n        RIGHT,\n    }\n\n    export enum AlignmentMethodV {\n        CENTER,\n        TOP,\n        BOTTOM\n    }\n\n    export class Display {\n        ctx: Image\n        elements: Element[]\n        constructor() {\n            this.ctx = image.create(screen.width, screen.height)\n            this.elements = []\n        }\n        clear() {\n            this.ctx.fill(game.Color.Black)\n        }\n        draw() {\n            for (let element of this.elements) {\n                element.draw(this.ctx)\n            }\n        }\n        show() {\n            scene.setBackgroundImage(this.ctx)\n        }\n        clicked(position: Vector2) {\n            for (let element of this.elements) {\n                this.clickedOn(element, position)\n            }\n        }\n        private clickedOn(element: Element, position: Vector2) {\n            if (element instanceof Container) {\n                let container = element as Container\n                for (let child of container.children) {\n                    this.clickedOn(child, position)\n                }\n            }\n            if (element instanceof Clickable) {\n                let clickable = element as Clickable\n                if (clickable.clickable && clickable.pointInside(position)) {\n                    clickable.onClick(position)\n                }\n            }\n        }\n    }\n\n    interface Border {\n        border: boolean\n        setBorder(on: boolean): Element\n        borderColor: color\n        setBorderColor(color: color): Element\n        borderWidth: number\n        setBorderWidth(width: number): Element\n    }\n\n    interface Position {\n        position: Vector2\n        setPosition(position: Vector2): Element\n        positionMethod: PositionMethod\n        setPositionMethod(method: PositionMethod): Element\n        size: Vector2\n        setSize(size: Vector2): Element\n    }\n\n    interface Color {\n        color: color\n        setColor(color: color): Element\n    }\n\n    interface Click {\n        clickable: boolean\n        pointInside(position: Vector2): boolean\n        onClick: (position: Vector2) => void\n        setOnClick(onClick: (position: Vector2) => void): Element\n    }\n\n    class Element implements Position {\n        parent: Container\n        position: Vector2\n        size: Vector2\n        positionMethod: PositionMethod\n        constructor(position: Vector2, size: Vector2) {\n            this.parent = null\n            this.position = position\n            this.size = size\n        }\n\n        draw(ctx: Image): void { }\n\n        setParent(container: Container): void {\n            this.parent = container\n            container.children.push(this)\n        }\n\n        setPosition(position: Vector2): Element {\n            this.position = position\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Element {\n            this.positionMethod = method\n            return this\n        }\n\n        setSize(size: Vector2): Element {\n            this.size = size\n            return this\n        }\n    }\n\n    class Clickable extends Element implements Click {\n        clickable: boolean\n        onClick: (position: Vector2) => void\n\n        constructor(position: Vector2, size: Vector2) {\n            super(position, size)\n            this.clickable = false\n        }\n\n        pointInside(position: Vector2): boolean {\n            return false\n        }\n\n        setOnClick(onClick: (position: Vector2) => void): Clickable {\n            this.onClick = onClick\n            this.clickable = true\n            return this\n        }\n    }\n\n    export enum FontSize {\n        Small,\n        Medium,\n        Large\n    }\n    export enum TextWrapMode {\n        Wrap,\n        Cut,\n        Ellipsis\n        // scroll text?\n    }\n    export class TextElement extends Element {\n        text: string\n        color: color\n        fontSize: FontSize\n        \n        constructor(position: Vector2, text: string, color?: color) {\n            super(position, Vector2.zero)\n            this.text = text\n            this.color = color ? color : game.Color.Black\n            this.fontSize = FontSize.Small\n        }\n\n        private get font(): image.Font {\n            switch (this.fontSize) {\n                case FontSize.Small: {\n                    return image.font5\n                    break\n                }\n                case FontSize.Medium: {\n                    return image.font8\n                    break\n                }\n                case FontSize.Large: {\n                    return image.font12\n                    break\n                }\n            }\n        }\n\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    ctx.print(this.text, 0, 0, this.color, this.font)\n                    break\n                }\n            }\n        }\n\n        setText(text: string): TextElement {\n            this.text = text\n            return this\n        }\n\n        setTextSize(size: FontSize): TextElement {\n            this.fontSize = size\n            return this\n        }\n    }\n\n    export class ImageElement extends Element {\n        img: Image\n        constructor(position: Vector2, img: Image) {\n            super(position, new Vector2(img.width, img.height))\n            this.img = img\n        }\n\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    ctx.blit(\n                        this.position.x - this.size.x / 2,\n                        this.position.y - this.size.y / 2,\n                        this.size.x, this.size.y,\n                        this.img, 0, 0,\n                        this.size.x, this.size.y,\n                        true, false\n                    )\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    ctx.blit(\n                        this.position.x, this.position.y,\n                        this.size.x, this.size.y,\n                        this.img, 0, 0,\n                        this.size.x, this.size.y,\n                        true, false\n                    )\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): ImageElement {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(position: Vector2): ImageElement {\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): ImageElement {\n            super.setPositionMethod(method)\n            return this\n        }\n    }\n\n    export class Box extends Clickable implements Border, Color {\n        color: color\n\n        border: boolean\n        borderColor: color\n        borderWidth: number\n\n        constructor(position: Vector2, size: Vector2, color?: color) {\n            super(position, size)\n            this.positionMethod = PositionMethod.CENTER\n\n            this.color = color ? color : game.Color.Tan\n\n            this.border = false\n            this.borderWidth = 1\n            this.borderColor = game.Color.Black\n        }\n\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    if (this.border) {\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2, this.position.y - this.size.y / 2,\n                            this.size.x, this.size.y,\n                            this.borderColor\n                        )\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2 + this.borderWidth,\n                            this.position.y - this.size.y / 2 + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2, this.position.y - this.size.y / 2,\n                            this.size.x, this.size.y,\n                            this.color\n                        )\n                    }\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    if (this.border) {\n                        ctx.fillRect(\n                            this.position.x, this.position.y,\n                            this.size.x, this.size.y,\n                            this.borderColor\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth, this.position.y + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillRect(\n                            this.position.x, this.position.y,\n                            this.size.x, this.size.y,\n                            this.color\n                        )\n                    }\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): Box {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(size: Vector2): Box {\n            super.setSize(size)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Box {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setColor(color: color): Box {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): Box {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): Box {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): Box {\n            this.borderWidth = width\n            return this\n        }\n\n        pointInside(position: Vector2): boolean {\n            let left, right, top, bottom\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    left = this.position.x\n                    right = this.position.x + this.size.x\n                    top = this.position.y\n                    bottom = this.position.y + this.size.y\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    left = this.position.x - this.size.x / 2\n                    right = this.position.x + this.size.x / 2\n                    top = this.position.y - this.size.y / 2\n                    bottom = this.position.y + this.size.y / 2\n                    break\n                }\n            }\n            return position.x >= left && position.x < right && position.y < bottom && position.y > top\n        }\n\n        setOnClick(onClick: (position: Vector2) => void): Box {\n            this.onClick = onClick\n            this.clickable = true\n            return this\n        }\n    }\n\n    export class Circle extends Clickable implements Border, Color {\n        radius: number\n\n        color: color\n\n        border: boolean\n        borderColor: color\n        borderWidth: number\n\n        constructor(position: Vector2, radius: number, color?: color) {\n            super(position, new Vector2(radius * 2, radius * 2))\n            this.positionMethod = PositionMethod.CENTER\n            this.radius = radius\n\n            this.color = color ? color : game.Color.Tan\n\n            this.border = false\n            this.borderColor = game.Color.Black\n            this.borderWidth = 1\n        }\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    if (this.border) {\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius, this.borderColor)\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius - this.borderWidth, this.color)\n                    } else {\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius, this.color)\n                    }\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    if (this.border) {\n                        this.singleCircle(ctx, this.position.x - this.radius, this.position.y - this.radius, this.radius, this.borderColor)\n                        this.singleCircle(ctx, this.position.x - this.radius, this.position.y - this.radius, this.radius - this.borderWidth, this.color)\n                    } else {\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius, this.color)\n                    }\n                    break\n                }\n            }\n        }\n\n        private singleCircle(ctx: Image, x: number, y: number, radius: number, color: number) {\n            ctx.fillCircle(x - 1, y - 1, radius, color)\n            ctx.fillCircle(x - 1, y, radius, color)\n            ctx.fillCircle(x, y - 1, radius, color)\n            ctx.fillCircle(x, y, radius, color)\n        }\n\n        setPosition(position: Vector2): Circle {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(size: Vector2): Circle {\n            super.setSize(size)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Circle {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setColor(color: color): Circle {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): Circle {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): Circle {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): Circle {\n            this.borderWidth = width\n            return this\n        }\n\n        pointInside(position: Vector2): boolean {\n            return Vector2.distance(this.position, position) < this.radius\n        }\n\n        setOnClick(onClick: (position: Vector2) => void): Circle {\n            this.onClick = onClick\n            this.clickable = true\n            return this\n        }\n    }\n\n    export class RoundedBox extends Box {\n        cornerRadius: number\n        constructor(position: Vector2, size: Vector2, cornerRadius: number, color?: color) {\n            super(position, size, color)\n            this.cornerRadius = cornerRadius\n        }\n        draw(ctx: Image) {\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    let cornerRadius = Math.min(this.cornerRadius, Math.ceil(Math.min(this.size.x, this.size.y) / 2) - 1)\n                    let left = this.position.x + cornerRadius - 1\n                    let right = this.position.x + this.size.x - cornerRadius\n                    let top = this.position.y + cornerRadius - 1\n                    let bottom = this.position.y + this.size.y - cornerRadius\n                    if (this.border) {\n                        ctx.fillCircle(left, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.borderColor)\n\n                        ctx.fillRect(left, this.position.y, right - left, this.size.y, this.borderColor)\n                        ctx.fillRect(this.position.x, top, this.size.x, bottom - top, this.borderColor)\n\n                        ctx.fillCircle(left, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius - this.borderWidth, this.color)\n\n                        ctx.fillRect(\n                            left, this.position.y + this.borderWidth,\n                            right - left, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth, top,\n                            this.size.x - this.borderWidth * 2, bottom - top,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillCircle(left, top, cornerRadius, this.color)\n                        ctx.fillCircle(right, top, cornerRadius, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.color)\n\n                        ctx.fillRect(left, this.position.y, right - left, this.size.y, this.color)\n                        ctx.fillRect(this.position.x, top, this.size.x, bottom - top, this.color)\n                    }\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    let cornerRadius = Math.min(this.cornerRadius, Math.round(Math.min(this.size.x, this.size.y) / 2))\n                    let left = this.position.x - this.size.x / 2 + cornerRadius - 1\n                    let right = this.position.x + this.size.x / 2 - cornerRadius\n                    let top = this.position.y - this.size.y / 2 + cornerRadius - 1\n                    let bottom = this.position.y + this.size.y / 2 - cornerRadius\n\n                    if (this.border) {\n                        ctx.fillCircle(left, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.borderColor)\n\n                        ctx.fillRect(left, this.position.y - this.size.y / 2, right - left, this.size.y, this.borderColor)\n                        ctx.fillRect(this.position.x - this.size.x / 2, top, this.size.x, bottom - top, this.borderColor)\n\n                        ctx.fillCircle(left, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius - this.borderWidth, this.color)\n\n                        ctx.fillRect(\n                            left, this.position.y - this.size.y / 2 + this.borderWidth,\n                            right - left, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth - this.size.x / 2, top,\n                            this.size.x - this.borderWidth * 2, bottom - top,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillCircle(left, top, cornerRadius, this.color)\n                        ctx.fillCircle(right, top, cornerRadius, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.color)\n\n                        ctx.fillRect(left, this.position.y - this.size.y / 2, right - left, this.size.y, this.color)\n                        ctx.fillRect(this.position.x - this.size.x / 2, top, this.size.x, bottom - top, this.color)\n                    }\n\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): Box {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(size: Vector2): Box {\n            super.setSize(size)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Box {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setColor(color: color): RoundedBox {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): RoundedBox {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): RoundedBox {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): RoundedBox {\n            this.borderWidth = width\n            return this\n        }\n    }\n\n    class Container extends Element {\n        children: Element[]\n        shape: Clickable\n        constructor(position: Vector2, size: Vector2) {\n            super(position, size)\n            this.children = []\n        }\n\n        update() {\n            for (let child of this.children) {\n                if (child instanceof Container) {\n                    child.update()\n                }\n            }\n        }\n\n        draw(ctx: Image) {\n            this.update()\n            if (this.shape != null) {\n                this.shape.setPosition(this.position)\n                this.shape.setPositionMethod(this.positionMethod)\n                this.shape.setSize(this.size)\n                this.shape.draw(ctx)\n            }\n            for (let child of this.children) {\n                child.draw(ctx)\n            }\n        }\n\n        setPosition(position: Vector2): Container {\n            this.position = position\n            return this\n        }\n        setSize(size: Vector2): Container {\n            this.size = size\n            return this\n        }\n        setPositionMethod(method: PositionMethod): Container {\n            this.positionMethod = method\n            return this\n        }\n        setShape(shape: Clickable): Container {\n            this.shape = shape\n            return this\n        }\n        addChild(child: Element): Container {\n            child.setParent(this)\n            return this\n        }\n    }\n\n    export class VerticalStack extends Container {\n        spacing: number\n        alignmentMethod: AlignmentMethodH\n\n        constructor(position: Vector2, children?: Element[]) {\n            super(position, Vector2.zero)\n            this.spacing = 0\n            if (children) {\n                this.children = children\n                this.update()\n            }\n            this.alignmentMethod = AlignmentMethodH.CENTER\n        }\n\n        update(): void {\n            super.update()\n            this.size = new Vector2(0, this.spacing)\n            for (let child of this.children) {\n                this.size.y += child.size.y\n                this.size.y += this.spacing\n                this.size.x = Math.max(this.size.x, child.size.x)\n            }\n\n            this.size.x += this.spacing * 2\n\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    let offset = this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodH.LEFT: {\n                                child.setPosition(new Vector2(this.position.x, this.position.y + offset))\n                                break\n                            }\n                            case AlignmentMethodH.RIGHT: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x), this.position.y + offset))\n                                break\n                            }\n                            case AlignmentMethodH.CENTER: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x) / 2, this.position.y + offset))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    let offset = -this.size.y / 2 + this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodH.LEFT: {\n                                child.setPosition(new Vector2(this.position.x - (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodH.RIGHT: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodH.CENTER: {\n                                child.setPosition(new Vector2(this.position.x, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n            }\n        }\n\n        setSpacing(spacing: number): VerticalStack {\n            this.spacing = spacing\n            return this\n        }\n\n        setAlignmentMethod(method: AlignmentMethodH): VerticalStack {\n            this.alignmentMethod = method\n            return this\n        }\n\n        setPosition(position: Vector2): VerticalStack {\n            super.setPosition(position)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): VerticalStack {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setSize(size: Vector2): VerticalStack {\n            super.setSize(size)\n            return this\n        }\n\n        setShape(shape: Clickable): VerticalStack {\n            super.setShape(shape)\n            return this\n        }\n\n        addChild(child: Element): VerticalStack {\n            super.addChild(child)\n            return this\n        }\n    }\n\n    export class HorizontalStack extends Container {\n        spacing: number\n        alignmentMethod: AlignmentMethodV\n\n        constructor(position: Vector2, children?: Element[]) {\n            super(position, Vector2.zero)\n            this.spacing = 0\n            this.alignmentMethod = AlignmentMethodV.CENTER\n            if (children) {\n                this.children = children\n                this.update()\n            }\n        }\n\n        update(): void {\n            super.update()\n            this.size = new Vector2(this.spacing, 0)\n            for (let child of this.children) {\n                this.size.x += child.size.x\n                this.size.x += this.spacing\n                this.size.y = Math.max(this.size.y, child.size.y)\n            }\n\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    let offset = this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodV.TOP: {\n                                child.setPosition(new Vector2(this.position.x + offset, this.position.y))\n                                break\n                            }\n                            case AlignmentMethodV.BOTTOM: {\n                                child.setPosition(new Vector2(this.position.x + offset, this.position.y + (this.size.y - child.size.y)))\n                                break\n                            }\n                            case AlignmentMethodV.CENTER: {\n                                child.setPosition(new Vector2(this.position.x + offset, this.position.y + (this.size.y - child.size.y) / 2))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    let offset = -this.size.y / 2 + this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodV.TOP: {\n                                child.setPosition(new Vector2(this.position.x - (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodV.BOTTOM: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodV.CENTER: {\n                                child.setPosition(new Vector2(this.position.x, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n            }\n        }\n\n        setSpacing(spacing: number): HorizontalStack {\n            this.spacing = spacing\n            return this\n        }\n\n        setAlignmentMethod(method: AlignmentMethodV): HorizontalStack {\n            this.alignmentMethod = method\n            return this\n        }\n\n        setPosition(position: Vector2): HorizontalStack {\n            super.setPosition(position)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): HorizontalStack {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setSize(size: Vector2): HorizontalStack {\n            super.setSize(size)\n            return this\n        }\n\n        setShape(shape: Clickable): HorizontalStack {\n            super.setShape(shape)\n            return this\n        }\n\n        addChild(child: Element): HorizontalStack {\n            super.addChild(child)\n            return this\n        }\n    }\n\n    export class DepthStack extends Container {\n        spacing: number\n        alignmentMethodH: AlignmentMethodH\n        alignmentMethodV: AlignmentMethodV\n        constructor(position: Vector2, children?: Element[]) {\n            super(position, Vector2.zero)\n            if (children) {\n                this.children = children\n                this.update()\n            }\n            this.alignmentMethodH = AlignmentMethodH.CENTER\n            this.alignmentMethodV = AlignmentMethodV.CENTER\n            this.spacing = 0\n        }\n        update(): void {\n            super.update()\n            this.size = Vector2.zero\n            for (let child of this.children) {\n                child.setPositionMethod(this.positionMethod)\n                this.size = new Vector2(Math.max(this.size.x, child.size.x), Math.max(this.size.y, child.size.y))\n            }\n            this.size.x += this.spacing * 2\n            this.size.y += this.spacing * 2\n            for (let child of this.children) {\n                switch (this.positionMethod) {\n                    case PositionMethod.CENTER: {\n                        let position = Vector2.zero\n                        switch (this.alignmentMethodH) {\n                            case AlignmentMethodH.LEFT: {\n                                position.x = this.position.x - (this.size.x / 2 - this.spacing) + child.size.x / 2\n                                break\n                            }\n                            case AlignmentMethodH.CENTER: {\n                                position.x = this.position.x\n                                break\n                            }\n                            case AlignmentMethodH.RIGHT: {\n                                position.x = this.position.x + (this.size.x / 2 - this.spacing) - child.size.x / 2\n                                break\n                            }\n                        }\n                        switch (this.alignmentMethodV) {\n                            case AlignmentMethodV.TOP: {\n                                position.y = this.position.y - (this.size.y / 2 - this.spacing) + child.size.y / 2\n                                break\n                            }\n                            case AlignmentMethodV.CENTER: {\n                                position.y = this.position.y\n                                break\n                            }\n                            case AlignmentMethodV.BOTTOM: {\n                                position.y = this.position.y + (this.size.y / 2 - this.spacing) - child.size.y / 2\n                                break\n                            }\n                        }\n                        child.setPosition(position)\n                        break\n                    }\n                    case PositionMethod.TOP_LEFT: {\n                        let position = Vector2.zero\n                        switch (this.alignmentMethodH) {\n                            case AlignmentMethodH.LEFT: {\n                                position.x = this.position.x - (this.size.x / 2 - this.spacing) + child.size.x / 2\n                                break\n                            }\n                            case AlignmentMethodH.CENTER: {\n                                position.x = this.position.x\n                                break\n                            }\n                            case AlignmentMethodH.RIGHT: {\n                                position.x = this.position.x + (this.size.x / 2 - this.spacing) - child.size.x / 2\n                                break\n                            }\n                        }\n                        switch (this.alignmentMethodV) {\n                            case AlignmentMethodV.TOP: {\n                                position.y = this.position.y - (this.size.y / 2 - this.spacing) + child.size.y / 2\n                                break\n                            }\n                            case AlignmentMethodV.CENTER: {\n                                position.y = this.position.y\n                                break\n                            }\n                            case AlignmentMethodV.BOTTOM: {\n                                position.y = this.position.y + (this.size.y / 2 - this.spacing) - child.size.y / 2\n                                break\n                            }\n                        }\n                        position.x += this.size.x / 2\n                        position.y += this.size.y / 2\n                        child.setPosition(position)\n                        break\n                    }\n                }\n            }\n        }\n\n        setPosition(position: Vector2): DepthStack {\n            super.setPosition(position)\n            return this\n        }\n        setSize(size: Vector2): DepthStack {\n            super.setSize(size)\n            return this\n        }\n        setPositionMethod(method: PositionMethod): DepthStack {\n            super.setPositionMethod(method)\n            return this\n        }\n        setShape(shape: Clickable): DepthStack {\n            super.setShape(shape)\n            return this\n        }\n        addChild(child: Element): DepthStack {\n            super.addChild(child)\n            return this\n        }\n        setSpacing(spacing: number): DepthStack {\n            this.spacing = spacing\n            return this\n        }\n    }\n\n    export class Grid extends Container {\n        spacing: number\n\n        \n    }\n}","util.ts":"class Vector2 {\n    x: number\n    y: number\n    constructor(x: number, y: number) {\n        this.x = x\n        this.y = y\n    }\n\n    static get zero(): Vector2 {\n        return new Vector2(0, 0)\n    }\n\n    static distance(a: Vector2, b: Vector2): number {\n        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2))\n    }\n\n    toString(): string {\n        return `x: ${this.x}, y: ${this.y}`\n    }\n}","images.g.jres":"{\n    \"image1\": {\n        \"data\": \"hwQIAAgAAAAA8A8AAPAPAADwDwD//////////wDwDwAA8A8AAPAPAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"plus_icon\"\n    },\n    \"image2\": {\n        \"data\": \"hwQIAAgAAAAA8A8AAPAPAADwDwAA8A8AAPAPAADwDwAA8A8AAPAPAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"minus_icon\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myImages\"\n    }\n}","images.g.ts":"","pxt.json":"{\n    \"name\": \"ui\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"browser-events\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"ui.ts\",\n        \"util.ts\",\n        \"images.g.jres\",\n        \"images.g.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1758143795671,"editorVersion":"2.0.56","text":{"main.ts":"let d = new UI.Display()\r\n\r\nlet vs = new UI.VerticalStack(new Vector2(80, 60))\r\n    .setPositionMethod(UI.PositionMethod.CENTER)\r\n    .setSpacing(5)\r\n\r\nlet plus = new UI.DepthStack(Vector2.zero)\r\n    .setPositionMethod(UI.PositionMethod.CENTER)\r\nnew UI.Circle(Vector2.zero, 6)\r\n    .setBorder(true)\r\n    .setBorderWidth(1)\r\n    .setBorderColor(game.Color.Black)\r\n    .setColor(game.Color.Green)\r\n    .setOnClick((position: Vector2) => {\r\n        if (vs.children.length > 1) {\r\n            vs.children.insertAt(1, new UI.Circle(Vector2.zero, 4, game.Color.Pink))\r\n        } else {\r\n            let minus = new UI.DepthStack(Vector2.zero)\r\n                .setPositionMethod(UI.PositionMethod.CENTER)\r\n            new UI.Circle(Vector2.zero, 6)\r\n                .setBorder(true)\r\n                .setBorderWidth(1)\r\n                .setBorderColor(game.Color.Black)\r\n                .setColor(game.Color.Red)\r\n                .setOnClick((position: Vector2) => {\r\n                    vs.children.removeAt(1)\r\n                })\r\n                .setParent(minus)\r\n            new UI.ImageElement(Vector2.zero, assets.image`minus_icon`)\r\n                .setParent(minus)\r\n            vs.addChild(minus)\r\n        }\r\n    })\r\n    .setParent(plus)\r\nnew UI.ImageElement(Vector2.zero, assets.image`plus_icon`)\r\n    .setParent(plus)\r\n\r\nlet minus = new UI.DepthStack(Vector2.zero)\r\n    .setPositionMethod(UI.PositionMethod.CENTER)\r\nnew UI.Circle(Vector2.zero, 6)\r\n    .setBorder(true)\r\n    .setBorderWidth(1)\r\n    .setBorderColor(game.Color.Black)\r\n    .setColor(game.Color.Red)\r\n    .setOnClick((position: Vector2) => {\r\n        vs.children.removeAt(1)\r\n    })\r\n    .setParent(minus)\r\nnew UI.ImageElement(Vector2.zero,assets.image`minus_icon`)\r\n    .setParent(minus)\r\n    \r\nvs.addChild(plus).update()\r\nvs.addChild(minus).update()\r\nvs.setShape(\r\n    new UI.RoundedBox(vs.position, vs.size, 10, game.Color.LightBlue)\r\n        .setBorder(true)\r\n        .setBorderColor(game.Color.Purple)\r\n        .setBorderWidth(2)\r\n)\r\nd.elements.push(vs)\r\n\r\nbrowserEvents.MouseLeft.onEvent(browserEvents.MouseButtonEvent.Pressed, function(x: number, y: number) {\r\n    d.clicked(new Vector2(x, y))\r\n})\r\n\r\ngame.onUpdate(() => {\r\n    d.clear()\r\n    d.draw()\r\n    d.show()\r\n})","README.md":" ","assets.json":"","ui.ts":"namespace UI {\n    export enum PositionMethod {\n        CENTER,\n        TOP_LEFT\n    }\n\n    export enum AlignmentMethodH {\n        CENTER,\n        LEFT,\n        RIGHT,\n    }\n\n    export enum AlignmentMethodV {\n        CENTER,\n        TOP,\n        BOTTOM\n    }\n\n    export class Display {\n        ctx: Image\n        elements: Element[]\n        constructor() {\n            this.ctx = image.create(screen.width, screen.height)\n            this.elements = []\n        }\n        clear() {\n            this.ctx.fill(game.Color.Black)\n        }\n        draw() {\n            for (let element of this.elements) {\n                element.draw(this.ctx)\n            }\n        }\n        show() {\n            scene.setBackgroundImage(this.ctx)\n        }\n        clicked(position: Vector2) {\n            for (let element of this.elements) {\n                this.clickedOn(element, position)\n            }\n        }\n        private clickedOn(element: Element, position: Vector2) {\n            if (element instanceof Container) {\n                let container = element as Container\n                for (let child of container.children) {\n                    this.clickedOn(child, position)\n                }\n            }\n            if (element instanceof Clickable) {\n                let clickable = element as Clickable\n                if (clickable.clickable && clickable.pointInside(position)) {\n                    clickable.onClick(position)\n                }\n            }\n        }\n    }\n\n    interface Border {\n        border: boolean\n        setBorder(on: boolean): Element\n        borderColor: color\n        setBorderColor(color: color): Element\n        borderWidth: number\n        setBorderWidth(width: number): Element\n    }\n\n    interface Position {\n        position: Vector2\n        setPosition(position: Vector2): Element\n        positionMethod: PositionMethod\n        setPositionMethod(method: PositionMethod): Element\n        size: Vector2\n        setSize(size: Vector2): Element\n    }\n\n    interface Color {\n        color: color\n        setColor(color: color): Element\n    }\n\n    interface Click {\n        clickable: boolean\n        pointInside(position: Vector2): boolean\n        onClick: (position: Vector2) => void\n        setOnClick(onClick: (position: Vector2) => void): Element\n    }\n\n    class Element implements Position {\n        parent: Container\n        position: Vector2\n        size: Vector2\n        positionMethod: PositionMethod\n        constructor(position: Vector2, size: Vector2) {\n            this.parent = null\n            this.position = position\n            this.size = size\n        }\n\n        draw(ctx: Image): void { }\n\n        setParent(container: Container): void {\n            this.parent = container\n            container.children.push(this)\n        }\n\n        setPosition(position: Vector2): Element {\n            this.position = position\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Element {\n            this.positionMethod = method\n            return this\n        }\n\n        setSize(size: Vector2): Element {\n            this.size = size\n            return this\n        }\n    }\n\n    class Clickable extends Element implements Click {\n        clickable: boolean\n        onClick: (position: Vector2) => void\n\n        constructor(position: Vector2, size: Vector2) {\n            super(position, size)\n            this.clickable = false\n        }\n\n        pointInside(position: Vector2): boolean {\n            return false\n        }\n\n        setOnClick(onClick: (position: Vector2) => void): Clickable {\n            this.onClick = onClick\n            this.clickable = true\n            return this\n        }\n    }\n\n    export enum FontSize {\n        Small,\n        Medium,\n        Large\n    }\n    export enum TextWrapMode {\n        Wrap,\n        Cut,\n        Continue,\n        Ellipsis\n        // scroll text?\n    }\n    export class TextElement extends Element {\n        text: string\n        color: color\n        fontSize: FontSize\n        \n        constructor(position: Vector2, text: string, color?: color) {\n            super(position, Vector2.zero)\n            this.text = text\n            this.color = color ? color : game.Color.Black\n            this.fontSize = FontSize.Small\n        }\n\n        private get font(): image.Font {\n            switch (this.fontSize) {\n                case FontSize.Small: {\n                    return image.font5\n                    break\n                }\n                case FontSize.Medium: {\n                    return image.font8\n                    break\n                }\n                case FontSize.Large: {\n                    return image.font12\n                    break\n                }\n            }\n        }\n\n        private sizeOfText() {\n            \n        }\n\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    ctx.print(this.text, 0, 0, this.color, this.font)\n                    break\n                }\n            }\n        }\n\n        setText(text: string): TextElement {\n            this.text = text\n            return this\n        }\n\n        setTextSize(size: FontSize): TextElement {\n            this.fontSize = size\n            return this\n        }\n    }\n\n    export class ImageElement extends Element {\n        img: Image\n        constructor(position: Vector2, img: Image) {\n            super(position, new Vector2(img.width, img.height))\n            this.img = img\n        }\n\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    ctx.blit(\n                        this.position.x - this.size.x / 2,\n                        this.position.y - this.size.y / 2,\n                        this.size.x, this.size.y,\n                        this.img, 0, 0,\n                        this.size.x, this.size.y,\n                        true, false\n                    )\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    ctx.blit(\n                        this.position.x, this.position.y,\n                        this.size.x, this.size.y,\n                        this.img, 0, 0,\n                        this.size.x, this.size.y,\n                        true, false\n                    )\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): ImageElement {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(position: Vector2): ImageElement {\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): ImageElement {\n            super.setPositionMethod(method)\n            return this\n        }\n    }\n\n    export class Box extends Clickable implements Border, Color {\n        color: color\n\n        border: boolean\n        borderColor: color\n        borderWidth: number\n\n        constructor(position: Vector2, size: Vector2, color?: color) {\n            super(position, size)\n            this.positionMethod = PositionMethod.CENTER\n\n            this.color = color ? color : game.Color.Tan\n\n            this.border = false\n            this.borderWidth = 1\n            this.borderColor = game.Color.Black\n        }\n\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    if (this.border) {\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2, this.position.y - this.size.y / 2,\n                            this.size.x, this.size.y,\n                            this.borderColor\n                        )\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2 + this.borderWidth,\n                            this.position.y - this.size.y / 2 + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2, this.position.y - this.size.y / 2,\n                            this.size.x, this.size.y,\n                            this.color\n                        )\n                    }\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    if (this.border) {\n                        ctx.fillRect(\n                            this.position.x, this.position.y,\n                            this.size.x, this.size.y,\n                            this.borderColor\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth, this.position.y + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillRect(\n                            this.position.x, this.position.y,\n                            this.size.x, this.size.y,\n                            this.color\n                        )\n                    }\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): Box {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(size: Vector2): Box {\n            super.setSize(size)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Box {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setColor(color: color): Box {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): Box {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): Box {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): Box {\n            this.borderWidth = width\n            return this\n        }\n\n        pointInside(position: Vector2): boolean {\n            let left, right, top, bottom\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    left = this.position.x\n                    right = this.position.x + this.size.x\n                    top = this.position.y\n                    bottom = this.position.y + this.size.y\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    left = this.position.x - this.size.x / 2\n                    right = this.position.x + this.size.x / 2\n                    top = this.position.y - this.size.y / 2\n                    bottom = this.position.y + this.size.y / 2\n                    break\n                }\n            }\n            return position.x >= left && position.x < right && position.y < bottom && position.y > top\n        }\n\n        setOnClick(onClick: (position: Vector2) => void): Box {\n            this.onClick = onClick\n            this.clickable = true\n            return this\n        }\n    }\n\n    export class Circle extends Clickable implements Border, Color {\n        radius: number\n\n        color: color\n\n        border: boolean\n        borderColor: color\n        borderWidth: number\n\n        constructor(position: Vector2, radius: number, color?: color) {\n            super(position, new Vector2(radius * 2, radius * 2))\n            this.positionMethod = PositionMethod.CENTER\n            this.radius = radius\n\n            this.color = color ? color : game.Color.Tan\n\n            this.border = false\n            this.borderColor = game.Color.Black\n            this.borderWidth = 1\n        }\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    if (this.border) {\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius, this.borderColor)\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius - this.borderWidth, this.color)\n                    } else {\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius, this.color)\n                    }\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    if (this.border) {\n                        this.singleCircle(ctx, this.position.x - this.radius, this.position.y - this.radius, this.radius, this.borderColor)\n                        this.singleCircle(ctx, this.position.x - this.radius, this.position.y - this.radius, this.radius - this.borderWidth, this.color)\n                    } else {\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius, this.color)\n                    }\n                    break\n                }\n            }\n        }\n\n        private singleCircle(ctx: Image, x: number, y: number, radius: number, color: number) {\n            ctx.fillCircle(x - 1, y - 1, radius, color)\n            ctx.fillCircle(x - 1, y, radius, color)\n            ctx.fillCircle(x, y - 1, radius, color)\n            ctx.fillCircle(x, y, radius, color)\n        }\n\n        setPosition(position: Vector2): Circle {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(size: Vector2): Circle {\n            super.setSize(size)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Circle {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setColor(color: color): Circle {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): Circle {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): Circle {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): Circle {\n            this.borderWidth = width\n            return this\n        }\n\n        pointInside(position: Vector2): boolean {\n            return Vector2.distance(this.position, position) < this.radius\n        }\n\n        setOnClick(onClick: (position: Vector2) => void): Circle {\n            this.onClick = onClick\n            this.clickable = true\n            return this\n        }\n    }\n\n    export class RoundedBox extends Box {\n        cornerRadius: number\n        constructor(position: Vector2, size: Vector2, cornerRadius: number, color?: color) {\n            super(position, size, color)\n            this.cornerRadius = cornerRadius\n        }\n        draw(ctx: Image) {\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    let cornerRadius = Math.min(this.cornerRadius, Math.ceil(Math.min(this.size.x, this.size.y) / 2) - 1)\n                    let left = this.position.x + cornerRadius - 1\n                    let right = this.position.x + this.size.x - cornerRadius\n                    let top = this.position.y + cornerRadius - 1\n                    let bottom = this.position.y + this.size.y - cornerRadius\n                    if (this.border) {\n                        ctx.fillCircle(left, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.borderColor)\n\n                        ctx.fillRect(left, this.position.y, right - left, this.size.y, this.borderColor)\n                        ctx.fillRect(this.position.x, top, this.size.x, bottom - top, this.borderColor)\n\n                        ctx.fillCircle(left, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius - this.borderWidth, this.color)\n\n                        ctx.fillRect(\n                            left, this.position.y + this.borderWidth,\n                            right - left, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth, top,\n                            this.size.x - this.borderWidth * 2, bottom - top,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillCircle(left, top, cornerRadius, this.color)\n                        ctx.fillCircle(right, top, cornerRadius, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.color)\n\n                        ctx.fillRect(left, this.position.y, right - left, this.size.y, this.color)\n                        ctx.fillRect(this.position.x, top, this.size.x, bottom - top, this.color)\n                    }\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    let cornerRadius = Math.min(this.cornerRadius, Math.round(Math.min(this.size.x, this.size.y) / 2))\n                    let left = this.position.x - this.size.x / 2 + cornerRadius - 1\n                    let right = this.position.x + this.size.x / 2 - cornerRadius\n                    let top = this.position.y - this.size.y / 2 + cornerRadius - 1\n                    let bottom = this.position.y + this.size.y / 2 - cornerRadius\n\n                    if (this.border) {\n                        ctx.fillCircle(left, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.borderColor)\n\n                        ctx.fillRect(left, this.position.y - this.size.y / 2, right - left, this.size.y, this.borderColor)\n                        ctx.fillRect(this.position.x - this.size.x / 2, top, this.size.x, bottom - top, this.borderColor)\n\n                        ctx.fillCircle(left, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius - this.borderWidth, this.color)\n\n                        ctx.fillRect(\n                            left, this.position.y - this.size.y / 2 + this.borderWidth,\n                            right - left, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth - this.size.x / 2, top,\n                            this.size.x - this.borderWidth * 2, bottom - top,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillCircle(left, top, cornerRadius, this.color)\n                        ctx.fillCircle(right, top, cornerRadius, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.color)\n\n                        ctx.fillRect(left, this.position.y - this.size.y / 2, right - left, this.size.y, this.color)\n                        ctx.fillRect(this.position.x - this.size.x / 2, top, this.size.x, bottom - top, this.color)\n                    }\n\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): Box {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(size: Vector2): Box {\n            super.setSize(size)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Box {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setColor(color: color): RoundedBox {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): RoundedBox {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): RoundedBox {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): RoundedBox {\n            this.borderWidth = width\n            return this\n        }\n    }\n\n    class Container extends Element {\n        children: Element[]\n        shape: Clickable\n        constructor(position: Vector2, size: Vector2) {\n            super(position, size)\n            this.children = []\n        }\n\n        update() {\n            for (let child of this.children) {\n                if (child instanceof Container) {\n                    child.update()\n                }\n            }\n        }\n\n        draw(ctx: Image) {\n            this.update()\n            if (this.shape != null) {\n                this.shape.setPosition(this.position)\n                this.shape.setPositionMethod(this.positionMethod)\n                this.shape.setSize(this.size)\n                this.shape.draw(ctx)\n            }\n            for (let child of this.children) {\n                child.draw(ctx)\n            }\n        }\n\n        setPosition(position: Vector2): Container {\n            this.position = position\n            return this\n        }\n        setSize(size: Vector2): Container {\n            this.size = size\n            return this\n        }\n        setPositionMethod(method: PositionMethod): Container {\n            this.positionMethod = method\n            return this\n        }\n        setShape(shape: Clickable): Container {\n            this.shape = shape\n            return this\n        }\n        addChild(child: Element): Container {\n            child.setParent(this)\n            return this\n        }\n    }\n\n    export class VerticalStack extends Container {\n        spacing: number\n        alignmentMethod: AlignmentMethodH\n\n        constructor(position: Vector2, children?: Element[]) {\n            super(position, Vector2.zero)\n            this.spacing = 0\n            if (children) {\n                this.children = children\n                this.update()\n            }\n            this.alignmentMethod = AlignmentMethodH.CENTER\n        }\n\n        update(): void {\n            super.update()\n            this.size = new Vector2(0, this.spacing)\n            for (let child of this.children) {\n                this.size.y += child.size.y\n                this.size.y += this.spacing\n                this.size.x = Math.max(this.size.x, child.size.x)\n            }\n\n            this.size.x += this.spacing * 2\n\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    let offset = this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodH.LEFT: {\n                                child.setPosition(new Vector2(this.position.x, this.position.y + offset))\n                                break\n                            }\n                            case AlignmentMethodH.RIGHT: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x), this.position.y + offset))\n                                break\n                            }\n                            case AlignmentMethodH.CENTER: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x) / 2, this.position.y + offset))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    let offset = -this.size.y / 2 + this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodH.LEFT: {\n                                child.setPosition(new Vector2(this.position.x - (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodH.RIGHT: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodH.CENTER: {\n                                child.setPosition(new Vector2(this.position.x, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n            }\n        }\n\n        setSpacing(spacing: number): VerticalStack {\n            this.spacing = spacing\n            return this\n        }\n\n        setAlignmentMethod(method: AlignmentMethodH): VerticalStack {\n            this.alignmentMethod = method\n            return this\n        }\n\n        setPosition(position: Vector2): VerticalStack {\n            super.setPosition(position)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): VerticalStack {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setSize(size: Vector2): VerticalStack {\n            super.setSize(size)\n            return this\n        }\n\n        setShape(shape: Clickable): VerticalStack {\n            super.setShape(shape)\n            return this\n        }\n\n        addChild(child: Element): VerticalStack {\n            super.addChild(child)\n            return this\n        }\n    }\n\n    export class HorizontalStack extends Container {\n        spacing: number\n        alignmentMethod: AlignmentMethodV\n\n        constructor(position: Vector2, children?: Element[]) {\n            super(position, Vector2.zero)\n            this.spacing = 0\n            this.alignmentMethod = AlignmentMethodV.CENTER\n            if (children) {\n                this.children = children\n                this.update()\n            }\n        }\n\n        update(): void {\n            super.update()\n            this.size = new Vector2(this.spacing, 0)\n            for (let child of this.children) {\n                this.size.x += child.size.x\n                this.size.x += this.spacing\n                this.size.y = Math.max(this.size.y, child.size.y)\n            }\n\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    let offset = this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodV.TOP: {\n                                child.setPosition(new Vector2(this.position.x + offset, this.position.y))\n                                break\n                            }\n                            case AlignmentMethodV.BOTTOM: {\n                                child.setPosition(new Vector2(this.position.x + offset, this.position.y + (this.size.y - child.size.y)))\n                                break\n                            }\n                            case AlignmentMethodV.CENTER: {\n                                child.setPosition(new Vector2(this.position.x + offset, this.position.y + (this.size.y - child.size.y) / 2))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    let offset = -this.size.y / 2 + this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodV.TOP: {\n                                child.setPosition(new Vector2(this.position.x - (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodV.BOTTOM: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodV.CENTER: {\n                                child.setPosition(new Vector2(this.position.x, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n            }\n        }\n\n        setSpacing(spacing: number): HorizontalStack {\n            this.spacing = spacing\n            return this\n        }\n\n        setAlignmentMethod(method: AlignmentMethodV): HorizontalStack {\n            this.alignmentMethod = method\n            return this\n        }\n\n        setPosition(position: Vector2): HorizontalStack {\n            super.setPosition(position)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): HorizontalStack {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setSize(size: Vector2): HorizontalStack {\n            super.setSize(size)\n            return this\n        }\n\n        setShape(shape: Clickable): HorizontalStack {\n            super.setShape(shape)\n            return this\n        }\n\n        addChild(child: Element): HorizontalStack {\n            super.addChild(child)\n            return this\n        }\n    }\n\n    export class DepthStack extends Container {\n        spacing: number\n        alignmentMethodH: AlignmentMethodH\n        alignmentMethodV: AlignmentMethodV\n        constructor(position: Vector2, children?: Element[]) {\n            super(position, Vector2.zero)\n            if (children) {\n                this.children = children\n                this.update()\n            }\n            this.alignmentMethodH = AlignmentMethodH.CENTER\n            this.alignmentMethodV = AlignmentMethodV.CENTER\n            this.spacing = 0\n        }\n        update(): void {\n            super.update()\n            this.size = Vector2.zero\n            for (let child of this.children) {\n                child.setPositionMethod(this.positionMethod)\n                this.size = new Vector2(Math.max(this.size.x, child.size.x), Math.max(this.size.y, child.size.y))\n            }\n            this.size.x += this.spacing * 2\n            this.size.y += this.spacing * 2\n            for (let child of this.children) {\n                switch (this.positionMethod) {\n                    case PositionMethod.CENTER: {\n                        let position = Vector2.zero\n                        switch (this.alignmentMethodH) {\n                            case AlignmentMethodH.LEFT: {\n                                position.x = this.position.x - (this.size.x / 2 - this.spacing) + child.size.x / 2\n                                break\n                            }\n                            case AlignmentMethodH.CENTER: {\n                                position.x = this.position.x\n                                break\n                            }\n                            case AlignmentMethodH.RIGHT: {\n                                position.x = this.position.x + (this.size.x / 2 - this.spacing) - child.size.x / 2\n                                break\n                            }\n                        }\n                        switch (this.alignmentMethodV) {\n                            case AlignmentMethodV.TOP: {\n                                position.y = this.position.y - (this.size.y / 2 - this.spacing) + child.size.y / 2\n                                break\n                            }\n                            case AlignmentMethodV.CENTER: {\n                                position.y = this.position.y\n                                break\n                            }\n                            case AlignmentMethodV.BOTTOM: {\n                                position.y = this.position.y + (this.size.y / 2 - this.spacing) - child.size.y / 2\n                                break\n                            }\n                        }\n                        child.setPosition(position)\n                        break\n                    }\n                    case PositionMethod.TOP_LEFT: {\n                        let position = Vector2.zero\n                        switch (this.alignmentMethodH) {\n                            case AlignmentMethodH.LEFT: {\n                                position.x = this.position.x - (this.size.x / 2 - this.spacing) + child.size.x / 2\n                                break\n                            }\n                            case AlignmentMethodH.CENTER: {\n                                position.x = this.position.x\n                                break\n                            }\n                            case AlignmentMethodH.RIGHT: {\n                                position.x = this.position.x + (this.size.x / 2 - this.spacing) - child.size.x / 2\n                                break\n                            }\n                        }\n                        switch (this.alignmentMethodV) {\n                            case AlignmentMethodV.TOP: {\n                                position.y = this.position.y - (this.size.y / 2 - this.spacing) + child.size.y / 2\n                                break\n                            }\n                            case AlignmentMethodV.CENTER: {\n                                position.y = this.position.y\n                                break\n                            }\n                            case AlignmentMethodV.BOTTOM: {\n                                position.y = this.position.y + (this.size.y / 2 - this.spacing) - child.size.y / 2\n                                break\n                            }\n                        }\n                        position.x += this.size.x / 2\n                        position.y += this.size.y / 2\n                        child.setPosition(position)\n                        break\n                    }\n                }\n            }\n        }\n\n        setPosition(position: Vector2): DepthStack {\n            super.setPosition(position)\n            return this\n        }\n        setSize(size: Vector2): DepthStack {\n            super.setSize(size)\n            return this\n        }\n        setPositionMethod(method: PositionMethod): DepthStack {\n            super.setPositionMethod(method)\n            return this\n        }\n        setShape(shape: Clickable): DepthStack {\n            super.setShape(shape)\n            return this\n        }\n        addChild(child: Element): DepthStack {\n            super.addChild(child)\n            return this\n        }\n        setSpacing(spacing: number): DepthStack {\n            this.spacing = spacing\n            return this\n        }\n    }\n\n    export class Grid extends Container {\n        spacing: number\n\n        \n    }\n}","util.ts":"class Vector2 {\n    x: number\n    y: number\n    constructor(x: number, y: number) {\n        this.x = x\n        this.y = y\n    }\n\n    static get zero(): Vector2 {\n        return new Vector2(0, 0)\n    }\n\n    static distance(a: Vector2, b: Vector2): number {\n        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2))\n    }\n\n    toString(): string {\n        return `x: ${this.x}, y: ${this.y}`\n    }\n}","images.g.jres":"{\n    \"image1\": {\n        \"data\": \"hwQIAAgAAAAA8A8AAPAPAADwDwD//////////wDwDwAA8A8AAPAPAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"plus_icon\"\n    },\n    \"image2\": {\n        \"data\": \"hwQIAAgAAAAA8A8AAPAPAADwDwAA8A8AAPAPAADwDwAA8A8AAPAPAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"minus_icon\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myImages\"\n    }\n}","images.g.ts":"","pxt.json":"{\n    \"name\": \"ui\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"browser-events\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"ui.ts\",\n        \"util.ts\",\n        \"images.g.jres\",\n        \"images.g.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1758148203883,"editorVersion":"2.0.56","text":{"main.ts":"let d = new UI.Display()\r\n\r\nlet vs = new UI.VerticalStack(new Vector2(80, 60))\r\n    .setPositionMethod(UI.PositionMethod.CENTER)\r\n    .setSpacing(5)\r\n\r\nlet plus = new UI.DepthStack(Vector2.zero)\r\n    .setPositionMethod(UI.PositionMethod.CENTER)\r\nnew UI.Circle(Vector2.zero, 6)\r\n    .setBorder(true)\r\n    .setBorderWidth(1)\r\n    .setBorderColor(game.Color.Black)\r\n    .setColor(game.Color.Green)\r\n    .setOnClick((position: Vector2) => {\r\n        if (vs.children.length > 1) {\r\n            vs.children.insertAt(1, new UI.Circle(Vector2.zero, 4, game.Color.Pink))\r\n        } else {\r\n            let minus = new UI.DepthStack(Vector2.zero)\r\n                .setPositionMethod(UI.PositionMethod.CENTER)\r\n            new UI.Circle(Vector2.zero, 6)\r\n                .setBorder(true)\r\n                .setBorderWidth(1)\r\n                .setBorderColor(game.Color.Black)\r\n                .setColor(game.Color.Red)\r\n                .setOnClick((position: Vector2) => {\r\n                    vs.children.removeAt(1)\r\n                })\r\n                .setParent(minus)\r\n            new UI.ImageElement(Vector2.zero, assets.image`minus_icon`)\r\n                .setParent(minus)\r\n            vs.addChild(minus)\r\n        }\r\n    })\r\n    .setParent(plus)\r\nnew UI.ImageElement(Vector2.zero, assets.image`plus_icon`)\r\n    .setParent(plus)\r\n\r\nlet minus = new UI.DepthStack(Vector2.zero)\r\n    .setPositionMethod(UI.PositionMethod.CENTER)\r\nnew UI.Circle(Vector2.zero, 6)\r\n    .setBorder(true)\r\n    .setBorderWidth(1)\r\n    .setBorderColor(game.Color.Black)\r\n    .setColor(game.Color.Red)\r\n    .setOnClick((position: Vector2) => {\r\n        vs.children.removeAt(1)\r\n    })\r\n    .setParent(minus)\r\nnew UI.ImageElement(Vector2.zero,assets.image`minus_icon`)\r\n    .setParent(minus)\r\n    \r\nvs.addChild(plus).update()\r\nvs.addChild(minus).update()\r\nvs.setShape(\r\n    new UI.RoundedBox(vs.position, vs.size, 10, game.Color.LightBlue)\r\n        .setBorder(true)\r\n        .setBorderColor(game.Color.Purple)\r\n        .setBorderWidth(2)\r\n)\r\nd.elements.push(vs)\r\n\r\nbrowserEvents.MouseLeft.onEvent(browserEvents.MouseButtonEvent.Pressed, function(x: number, y: number) {\r\n    d.clicked(new Vector2(x, y))\r\n})\r\n\r\ngame.onUpdate(() => {\r\n    d.clear()\r\n    d.draw()\r\n    d.show()\r\n})","README.md":" ","assets.json":"","ui.ts":"namespace UI {\n    export enum PositionMethod {\n        CENTER,\n        TOP_LEFT\n    }\n\n    export enum AlignmentMethodH {\n        CENTER,\n        LEFT,\n        RIGHT,\n    }\n\n    export enum AlignmentMethodV {\n        CENTER,\n        TOP,\n        BOTTOM\n    }\n\n    export class Display {\n        ctx: Image\n        elements: Element[]\n        constructor() {\n            this.ctx = image.create(screen.width, screen.height)\n            this.elements = []\n        }\n        clear() {\n            this.ctx.fill(game.Color.Black)\n        }\n        draw() {\n            for (let element of this.elements) {\n                element.draw(this.ctx)\n            }\n        }\n        show() {\n            scene.setBackgroundImage(this.ctx)\n        }\n        clicked(position: Vector2) {\n            for (let element of this.elements) {\n                this.clickedOn(element, position)\n            }\n        }\n        private clickedOn(element: Element, position: Vector2) {\n            if (element instanceof Container) {\n                let container = element as Container\n                for (let child of container.children) {\n                    this.clickedOn(child, position)\n                }\n            }\n            if (element instanceof Clickable) {\n                let clickable = element as Clickable\n                if (clickable.clickable && clickable.pointInside(position)) {\n                    clickable.onClick(position)\n                }\n            }\n        }\n    }\n\n    interface Border {\n        border: boolean\n        setBorder(on: boolean): Element\n        borderColor: color\n        setBorderColor(color: color): Element\n        borderWidth: number\n        setBorderWidth(width: number): Element\n    }\n\n    interface Position {\n        position: Vector2\n        setPosition(position: Vector2): Element\n        positionMethod: PositionMethod\n        setPositionMethod(method: PositionMethod): Element\n        size: Vector2\n        setSize(size: Vector2): Element\n    }\n\n    interface Color {\n        color: color\n        setColor(color: color): Element\n    }\n\n    interface Click {\n        clickable: boolean\n        pointInside(position: Vector2): boolean\n        onClick: (position: Vector2) => void\n        setOnClick(onClick: (position: Vector2) => void): Element\n    }\n\n    class Element implements Position {\n        parent: Container\n        position: Vector2\n        size: Vector2\n        positionMethod: PositionMethod\n        constructor(position: Vector2, size: Vector2) {\n            this.parent = null\n            this.position = position\n            this.size = size\n        }\n\n        draw(ctx: Image): void { }\n\n        setParent(container: Container): void {\n            this.parent = container\n            container.children.push(this)\n        }\n\n        setPosition(position: Vector2): Element {\n            this.position = position\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Element {\n            this.positionMethod = method\n            return this\n        }\n\n        setSize(size: Vector2): Element {\n            this.size = size\n            return this\n        }\n    }\n\n    class Clickable extends Element implements Click {\n        clickable: boolean\n        onClick: (position: Vector2) => void\n\n        constructor(position: Vector2, size: Vector2) {\n            super(position, size)\n            this.clickable = false\n        }\n\n        pointInside(position: Vector2): boolean {\n            return false\n        }\n\n        setOnClick(onClick: (position: Vector2) => void): Clickable {\n            this.onClick = onClick\n            this.clickable = true\n            return this\n        }\n    }\n\n    export enum FontSize {\n        Small,\n        Medium,\n        Large\n    }\n    export enum TextWrapMode {\n        Wrap,\n        Cut,\n        Continue,\n        Ellipsis\n        // scroll text?\n    }\n    export class TextElement extends Element {\n        text: string\n        color: color\n        fontSize: FontSize\n        \n        constructor(position: Vector2, text: string, color?: color) {\n            super(position, Vector2.zero)\n            this.text = text\n            this.color = color ? color : game.Color.Black\n            this.fontSize = FontSize.Small\n        }\n\n        private get font(): image.Font {\n            switch (this.fontSize) {\n                case FontSize.Small: {\n                    return image.font5\n                    break\n                }\n                case FontSize.Medium: {\n                    return image.font8\n                    break\n                }\n                case FontSize.Large: {\n                    return image.font12\n                    break\n                }\n            }\n        }\n\n        private static textGridSize(text: string): Vector2 {\n            let rows = text.split(\"\\n\")\n            let maxColumns = rows.reduce((max: number, current: string) => {\n                return Math.max(max, current.replace(\"\\n\", \"\").length)\n            }, 0)\n            return new Vector2(rows.length, maxColumns)\n        }\n\n        private sizeOfText(text: string): Vector2 {\n            let gridSize = TextElement.textGridSize(text)\n            switch (this.fontSize) {\n                case FontSize.Small: {\n                    gridSize.x *= 5\n                    gridSize.y *= 7\n                    break\n                }\n                case FontSize.Medium: {\n                    gridSize.x *= 6\n                    gridSize.y *= 10\n                    break\n                }\n                case FontSize.Large: {\n                    gridSize.x *= 12\n                    gridSize.y *= 14\n                    break\n                }\n            }\n            return gridSize\n        }\n\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    ctx.print(this.text, 0, 0, this.color, this.font)\n                    break\n                }\n            }\n        }\n\n        setText(text: string): TextElement {\n            this.text = text\n            return this\n        }\n\n        setTextSize(size: FontSize): TextElement {\n            this.fontSize = size\n            return this\n        }\n    }\n\n    export class ImageElement extends Element {\n        img: Image\n        constructor(position: Vector2, img: Image) {\n            super(position, new Vector2(img.width, img.height))\n            this.img = img\n        }\n\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    ctx.blit(\n                        this.position.x - this.size.x / 2,\n                        this.position.y - this.size.y / 2,\n                        this.size.x, this.size.y,\n                        this.img, 0, 0,\n                        this.size.x, this.size.y,\n                        true, false\n                    )\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    ctx.blit(\n                        this.position.x, this.position.y,\n                        this.size.x, this.size.y,\n                        this.img, 0, 0,\n                        this.size.x, this.size.y,\n                        true, false\n                    )\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): ImageElement {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(position: Vector2): ImageElement {\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): ImageElement {\n            super.setPositionMethod(method)\n            return this\n        }\n    }\n\n    export class Box extends Clickable implements Border, Color {\n        color: color\n\n        border: boolean\n        borderColor: color\n        borderWidth: number\n\n        constructor(position: Vector2, size: Vector2, color?: color) {\n            super(position, size)\n            this.positionMethod = PositionMethod.CENTER\n\n            this.color = color ? color : game.Color.Tan\n\n            this.border = false\n            this.borderWidth = 1\n            this.borderColor = game.Color.Black\n        }\n\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    if (this.border) {\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2, this.position.y - this.size.y / 2,\n                            this.size.x, this.size.y,\n                            this.borderColor\n                        )\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2 + this.borderWidth,\n                            this.position.y - this.size.y / 2 + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2, this.position.y - this.size.y / 2,\n                            this.size.x, this.size.y,\n                            this.color\n                        )\n                    }\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    if (this.border) {\n                        ctx.fillRect(\n                            this.position.x, this.position.y,\n                            this.size.x, this.size.y,\n                            this.borderColor\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth, this.position.y + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillRect(\n                            this.position.x, this.position.y,\n                            this.size.x, this.size.y,\n                            this.color\n                        )\n                    }\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): Box {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(size: Vector2): Box {\n            super.setSize(size)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Box {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setColor(color: color): Box {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): Box {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): Box {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): Box {\n            this.borderWidth = width\n            return this\n        }\n\n        pointInside(position: Vector2): boolean {\n            let left, right, top, bottom\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    left = this.position.x\n                    right = this.position.x + this.size.x\n                    top = this.position.y\n                    bottom = this.position.y + this.size.y\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    left = this.position.x - this.size.x / 2\n                    right = this.position.x + this.size.x / 2\n                    top = this.position.y - this.size.y / 2\n                    bottom = this.position.y + this.size.y / 2\n                    break\n                }\n            }\n            return position.x >= left && position.x < right && position.y < bottom && position.y > top\n        }\n\n        setOnClick(onClick: (position: Vector2) => void): Box {\n            this.onClick = onClick\n            this.clickable = true\n            return this\n        }\n    }\n\n    export class Circle extends Clickable implements Border, Color {\n        radius: number\n\n        color: color\n\n        border: boolean\n        borderColor: color\n        borderWidth: number\n\n        constructor(position: Vector2, radius: number, color?: color) {\n            super(position, new Vector2(radius * 2, radius * 2))\n            this.positionMethod = PositionMethod.CENTER\n            this.radius = radius\n\n            this.color = color ? color : game.Color.Tan\n\n            this.border = false\n            this.borderColor = game.Color.Black\n            this.borderWidth = 1\n        }\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    if (this.border) {\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius, this.borderColor)\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius - this.borderWidth, this.color)\n                    } else {\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius, this.color)\n                    }\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    if (this.border) {\n                        this.singleCircle(ctx, this.position.x - this.radius, this.position.y - this.radius, this.radius, this.borderColor)\n                        this.singleCircle(ctx, this.position.x - this.radius, this.position.y - this.radius, this.radius - this.borderWidth, this.color)\n                    } else {\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius, this.color)\n                    }\n                    break\n                }\n            }\n        }\n\n        private singleCircle(ctx: Image, x: number, y: number, radius: number, color: number) {\n            ctx.fillCircle(x - 1, y - 1, radius, color)\n            ctx.fillCircle(x - 1, y, radius, color)\n            ctx.fillCircle(x, y - 1, radius, color)\n            ctx.fillCircle(x, y, radius, color)\n        }\n\n        setPosition(position: Vector2): Circle {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(size: Vector2): Circle {\n            super.setSize(size)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Circle {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setColor(color: color): Circle {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): Circle {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): Circle {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): Circle {\n            this.borderWidth = width\n            return this\n        }\n\n        pointInside(position: Vector2): boolean {\n            return Vector2.distance(this.position, position) < this.radius\n        }\n\n        setOnClick(onClick: (position: Vector2) => void): Circle {\n            this.onClick = onClick\n            this.clickable = true\n            return this\n        }\n    }\n\n    export class RoundedBox extends Box {\n        cornerRadius: number\n        constructor(position: Vector2, size: Vector2, cornerRadius: number, color?: color) {\n            super(position, size, color)\n            this.cornerRadius = cornerRadius\n        }\n        draw(ctx: Image) {\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    let cornerRadius = Math.min(this.cornerRadius, Math.ceil(Math.min(this.size.x, this.size.y) / 2) - 1)\n                    let left = this.position.x + cornerRadius - 1\n                    let right = this.position.x + this.size.x - cornerRadius\n                    let top = this.position.y + cornerRadius - 1\n                    let bottom = this.position.y + this.size.y - cornerRadius\n                    if (this.border) {\n                        ctx.fillCircle(left, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.borderColor)\n\n                        ctx.fillRect(left, this.position.y, right - left, this.size.y, this.borderColor)\n                        ctx.fillRect(this.position.x, top, this.size.x, bottom - top, this.borderColor)\n\n                        ctx.fillCircle(left, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius - this.borderWidth, this.color)\n\n                        ctx.fillRect(\n                            left, this.position.y + this.borderWidth,\n                            right - left, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth, top,\n                            this.size.x - this.borderWidth * 2, bottom - top,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillCircle(left, top, cornerRadius, this.color)\n                        ctx.fillCircle(right, top, cornerRadius, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.color)\n\n                        ctx.fillRect(left, this.position.y, right - left, this.size.y, this.color)\n                        ctx.fillRect(this.position.x, top, this.size.x, bottom - top, this.color)\n                    }\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    let cornerRadius = Math.min(this.cornerRadius, Math.round(Math.min(this.size.x, this.size.y) / 2))\n                    let left = this.position.x - this.size.x / 2 + cornerRadius - 1\n                    let right = this.position.x + this.size.x / 2 - cornerRadius\n                    let top = this.position.y - this.size.y / 2 + cornerRadius - 1\n                    let bottom = this.position.y + this.size.y / 2 - cornerRadius\n\n                    if (this.border) {\n                        ctx.fillCircle(left, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.borderColor)\n\n                        ctx.fillRect(left, this.position.y - this.size.y / 2, right - left, this.size.y, this.borderColor)\n                        ctx.fillRect(this.position.x - this.size.x / 2, top, this.size.x, bottom - top, this.borderColor)\n\n                        ctx.fillCircle(left, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius - this.borderWidth, this.color)\n\n                        ctx.fillRect(\n                            left, this.position.y - this.size.y / 2 + this.borderWidth,\n                            right - left, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth - this.size.x / 2, top,\n                            this.size.x - this.borderWidth * 2, bottom - top,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillCircle(left, top, cornerRadius, this.color)\n                        ctx.fillCircle(right, top, cornerRadius, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.color)\n\n                        ctx.fillRect(left, this.position.y - this.size.y / 2, right - left, this.size.y, this.color)\n                        ctx.fillRect(this.position.x - this.size.x / 2, top, this.size.x, bottom - top, this.color)\n                    }\n\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): Box {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(size: Vector2): Box {\n            super.setSize(size)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Box {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setColor(color: color): RoundedBox {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): RoundedBox {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): RoundedBox {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): RoundedBox {\n            this.borderWidth = width\n            return this\n        }\n    }\n\n    class Container extends Element {\n        children: Element[]\n        shape: Clickable\n        constructor(position: Vector2, size: Vector2) {\n            super(position, size)\n            this.children = []\n        }\n\n        update() {\n            for (let child of this.children) {\n                if (child instanceof Container) {\n                    child.update()\n                }\n            }\n        }\n\n        draw(ctx: Image) {\n            this.update()\n            if (this.shape != null) {\n                this.shape.setPosition(this.position)\n                this.shape.setPositionMethod(this.positionMethod)\n                this.shape.setSize(this.size)\n                this.shape.draw(ctx)\n            }\n            for (let child of this.children) {\n                child.draw(ctx)\n            }\n        }\n\n        setPosition(position: Vector2): Container {\n            this.position = position\n            return this\n        }\n        setSize(size: Vector2): Container {\n            this.size = size\n            return this\n        }\n        setPositionMethod(method: PositionMethod): Container {\n            this.positionMethod = method\n            return this\n        }\n        setShape(shape: Clickable): Container {\n            this.shape = shape\n            return this\n        }\n        addChild(child: Element): Container {\n            child.setParent(this)\n            return this\n        }\n    }\n\n    export class VerticalStack extends Container {\n        spacing: number\n        alignmentMethod: AlignmentMethodH\n\n        constructor(position: Vector2, children?: Element[]) {\n            super(position, Vector2.zero)\n            this.spacing = 0\n            if (children) {\n                this.children = children\n                this.update()\n            }\n            this.alignmentMethod = AlignmentMethodH.CENTER\n        }\n\n        update(): void {\n            super.update()\n            this.size = new Vector2(0, this.spacing)\n            for (let child of this.children) {\n                this.size.y += child.size.y\n                this.size.y += this.spacing\n                this.size.x = Math.max(this.size.x, child.size.x)\n            }\n\n            this.size.x += this.spacing * 2\n\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    let offset = this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodH.LEFT: {\n                                child.setPosition(new Vector2(this.position.x, this.position.y + offset))\n                                break\n                            }\n                            case AlignmentMethodH.RIGHT: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x), this.position.y + offset))\n                                break\n                            }\n                            case AlignmentMethodH.CENTER: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x) / 2, this.position.y + offset))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    let offset = -this.size.y / 2 + this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodH.LEFT: {\n                                child.setPosition(new Vector2(this.position.x - (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodH.RIGHT: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodH.CENTER: {\n                                child.setPosition(new Vector2(this.position.x, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n            }\n        }\n\n        setSpacing(spacing: number): VerticalStack {\n            this.spacing = spacing\n            return this\n        }\n\n        setAlignmentMethod(method: AlignmentMethodH): VerticalStack {\n            this.alignmentMethod = method\n            return this\n        }\n\n        setPosition(position: Vector2): VerticalStack {\n            super.setPosition(position)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): VerticalStack {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setSize(size: Vector2): VerticalStack {\n            super.setSize(size)\n            return this\n        }\n\n        setShape(shape: Clickable): VerticalStack {\n            super.setShape(shape)\n            return this\n        }\n\n        addChild(child: Element): VerticalStack {\n            super.addChild(child)\n            return this\n        }\n    }\n\n    export class HorizontalStack extends Container {\n        spacing: number\n        alignmentMethod: AlignmentMethodV\n\n        constructor(position: Vector2, children?: Element[]) {\n            super(position, Vector2.zero)\n            this.spacing = 0\n            this.alignmentMethod = AlignmentMethodV.CENTER\n            if (children) {\n                this.children = children\n                this.update()\n            }\n        }\n\n        update(): void {\n            super.update()\n            this.size = new Vector2(this.spacing, 0)\n            for (let child of this.children) {\n                this.size.x += child.size.x\n                this.size.x += this.spacing\n                this.size.y = Math.max(this.size.y, child.size.y)\n            }\n\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    let offset = this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodV.TOP: {\n                                child.setPosition(new Vector2(this.position.x + offset, this.position.y))\n                                break\n                            }\n                            case AlignmentMethodV.BOTTOM: {\n                                child.setPosition(new Vector2(this.position.x + offset, this.position.y + (this.size.y - child.size.y)))\n                                break\n                            }\n                            case AlignmentMethodV.CENTER: {\n                                child.setPosition(new Vector2(this.position.x + offset, this.position.y + (this.size.y - child.size.y) / 2))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    let offset = -this.size.y / 2 + this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodV.TOP: {\n                                child.setPosition(new Vector2(this.position.x - (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodV.BOTTOM: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodV.CENTER: {\n                                child.setPosition(new Vector2(this.position.x, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n            }\n        }\n\n        setSpacing(spacing: number): HorizontalStack {\n            this.spacing = spacing\n            return this\n        }\n\n        setAlignmentMethod(method: AlignmentMethodV): HorizontalStack {\n            this.alignmentMethod = method\n            return this\n        }\n\n        setPosition(position: Vector2): HorizontalStack {\n            super.setPosition(position)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): HorizontalStack {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setSize(size: Vector2): HorizontalStack {\n            super.setSize(size)\n            return this\n        }\n\n        setShape(shape: Clickable): HorizontalStack {\n            super.setShape(shape)\n            return this\n        }\n\n        addChild(child: Element): HorizontalStack {\n            super.addChild(child)\n            return this\n        }\n    }\n\n    export class DepthStack extends Container {\n        spacing: number\n        alignmentMethodH: AlignmentMethodH\n        alignmentMethodV: AlignmentMethodV\n        constructor(position: Vector2, children?: Element[]) {\n            super(position, Vector2.zero)\n            if (children) {\n                this.children = children\n                this.update()\n            }\n            this.alignmentMethodH = AlignmentMethodH.CENTER\n            this.alignmentMethodV = AlignmentMethodV.CENTER\n            this.spacing = 0\n        }\n        update(): void {\n            super.update()\n            this.size = Vector2.zero\n            for (let child of this.children) {\n                child.setPositionMethod(this.positionMethod)\n                this.size = new Vector2(Math.max(this.size.x, child.size.x), Math.max(this.size.y, child.size.y))\n            }\n            this.size.x += this.spacing * 2\n            this.size.y += this.spacing * 2\n            for (let child of this.children) {\n                switch (this.positionMethod) {\n                    case PositionMethod.CENTER: {\n                        let position = Vector2.zero\n                        switch (this.alignmentMethodH) {\n                            case AlignmentMethodH.LEFT: {\n                                position.x = this.position.x - (this.size.x / 2 - this.spacing) + child.size.x / 2\n                                break\n                            }\n                            case AlignmentMethodH.CENTER: {\n                                position.x = this.position.x\n                                break\n                            }\n                            case AlignmentMethodH.RIGHT: {\n                                position.x = this.position.x + (this.size.x / 2 - this.spacing) - child.size.x / 2\n                                break\n                            }\n                        }\n                        switch (this.alignmentMethodV) {\n                            case AlignmentMethodV.TOP: {\n                                position.y = this.position.y - (this.size.y / 2 - this.spacing) + child.size.y / 2\n                                break\n                            }\n                            case AlignmentMethodV.CENTER: {\n                                position.y = this.position.y\n                                break\n                            }\n                            case AlignmentMethodV.BOTTOM: {\n                                position.y = this.position.y + (this.size.y / 2 - this.spacing) - child.size.y / 2\n                                break\n                            }\n                        }\n                        child.setPosition(position)\n                        break\n                    }\n                    case PositionMethod.TOP_LEFT: {\n                        let position = Vector2.zero\n                        switch (this.alignmentMethodH) {\n                            case AlignmentMethodH.LEFT: {\n                                position.x = this.position.x - (this.size.x / 2 - this.spacing) + child.size.x / 2\n                                break\n                            }\n                            case AlignmentMethodH.CENTER: {\n                                position.x = this.position.x\n                                break\n                            }\n                            case AlignmentMethodH.RIGHT: {\n                                position.x = this.position.x + (this.size.x / 2 - this.spacing) - child.size.x / 2\n                                break\n                            }\n                        }\n                        switch (this.alignmentMethodV) {\n                            case AlignmentMethodV.TOP: {\n                                position.y = this.position.y - (this.size.y / 2 - this.spacing) + child.size.y / 2\n                                break\n                            }\n                            case AlignmentMethodV.CENTER: {\n                                position.y = this.position.y\n                                break\n                            }\n                            case AlignmentMethodV.BOTTOM: {\n                                position.y = this.position.y + (this.size.y / 2 - this.spacing) - child.size.y / 2\n                                break\n                            }\n                        }\n                        position.x += this.size.x / 2\n                        position.y += this.size.y / 2\n                        child.setPosition(position)\n                        break\n                    }\n                }\n            }\n        }\n\n        setPosition(position: Vector2): DepthStack {\n            super.setPosition(position)\n            return this\n        }\n        setSize(size: Vector2): DepthStack {\n            super.setSize(size)\n            return this\n        }\n        setPositionMethod(method: PositionMethod): DepthStack {\n            super.setPositionMethod(method)\n            return this\n        }\n        setShape(shape: Clickable): DepthStack {\n            super.setShape(shape)\n            return this\n        }\n        addChild(child: Element): DepthStack {\n            super.addChild(child)\n            return this\n        }\n        setSpacing(spacing: number): DepthStack {\n            this.spacing = spacing\n            return this\n        }\n    }\n\n    export class Grid extends Container {\n        spacing: number\n\n        \n    }\n}","util.ts":"class Vector2 {\n    x: number\n    y: number\n    constructor(x: number, y: number) {\n        this.x = x\n        this.y = y\n    }\n\n    scale(scalar: number) {\n        this.x *= scalar\n        this.y *= scalar\n    }\n\n    static get zero(): Vector2 {\n        return new Vector2(0, 0)\n    }\n\n    static distance(a: Vector2, b: Vector2): number {\n        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2))\n    }\n\n    toString(): string {\n        return `x: ${this.x}, y: ${this.y}`\n    }\n}","images.g.jres":"{\n    \"image1\": {\n        \"data\": \"hwQIAAgAAAAA8A8AAPAPAADwDwD//////////wDwDwAA8A8AAPAPAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"plus_icon\"\n    },\n    \"image2\": {\n        \"data\": \"hwQIAAgAAAAA8A8AAPAPAADwDwAA8A8AAPAPAADwDwAA8A8AAPAPAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"minus_icon\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myImages\"\n    }\n}","images.g.ts":"","pxt.json":"{\n    \"name\": \"ui\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"browser-events\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"ui.ts\",\n        \"util.ts\",\n        \"images.g.jres\",\n        \"images.g.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1758228831952,"editorVersion":"2.0.56","text":{"main.ts":"let d = new UI.Display()\r\n\r\nlet vs = new UI.VerticalStack(new Vector2(80, 60))\r\n    .setPositionMethod(UI.PositionMethod.CENTER)\r\n    .setSpacing(5)\r\n\r\nlet plus = new UI.DepthStack(Vector2.zero)\r\n    .setPositionMethod(UI.PositionMethod.CENTER)\r\nnew UI.Circle(Vector2.zero, 6)\r\n    .setBorder(true)\r\n    .setBorderWidth(1)\r\n    .setBorderColor(game.Color.Black)\r\n    .setColor(game.Color.Green)\r\n    .setOnClick((position: Vector2) => {\r\n        if (vs.children.length > 1) {\r\n            vs.children.insertAt(1, new UI.Circle(Vector2.zero, 4, game.Color.Pink))\r\n        } else {\r\n            let minus = new UI.DepthStack(Vector2.zero)\r\n                .setPositionMethod(UI.PositionMethod.CENTER)\r\n            new UI.Circle(Vector2.zero, 6)\r\n                .setBorder(true)\r\n                .setBorderWidth(1)\r\n                .setBorderColor(game.Color.Black)\r\n                .setColor(game.Color.Red)\r\n                .setOnClick((position: Vector2) => {\r\n                    vs.children.removeAt(1)\r\n                })\r\n                .setParent(minus)\r\n            new UI.ImageElement(Vector2.zero, assets.image`minus_icon`)\r\n                .setParent(minus)\r\n            vs.addChild(minus)\r\n        }\r\n    })\r\n    .setParent(plus)\r\nnew UI.ImageElement(Vector2.zero, assets.image`plus_icon`)\r\n    .setParent(plus)\r\n\r\nlet minus = new UI.DepthStack(Vector2.zero)\r\n    .setPositionMethod(UI.PositionMethod.CENTER)\r\nnew UI.Circle(Vector2.zero, 6)\r\n    .setBorder(true)\r\n    .setBorderWidth(1)\r\n    .setBorderColor(game.Color.Black)\r\n    .setColor(game.Color.Red)\r\n    .setOnClick((position: Vector2) => {\r\n        vs.children.removeAt(1)\r\n    })\r\n    .setParent(minus)\r\nnew UI.ImageElement(Vector2.zero,assets.image`minus_icon`)\r\n    .setParent(minus)\r\n    \r\nvs.addChild(plus).update()\r\nvs.addChild(minus).update()\r\nvs.setShape(\r\n    new UI.RoundedBox(vs.position, vs.size, 10, game.Color.LightBlue)\r\n        .setBorder(true)\r\n        .setBorderColor(game.Color.Purple)\r\n        .setBorderWidth(2)\r\n)\r\nd.elements.push(vs)\r\n\r\nbrowserEvents.MouseLeft.onEvent(browserEvents.MouseButtonEvent.Pressed, function(x: number, y: number) {\r\n    d.clicked(new Vector2(x, y))\r\n})\r\n\r\ngame.onUpdate(() => {\r\n    d.clear()\r\n    d.draw()\r\n    d.show()\r\n})","README.md":" ","assets.json":"","ui.ts":"namespace UI {\n    export enum PositionMethod {\n        CENTER,\n        TOP_LEFT\n    }\n\n    export enum AlignmentMethodH {\n        CENTER,\n        LEFT,\n        RIGHT,\n    }\n\n    export enum AlignmentMethodV {\n        CENTER,\n        TOP,\n        BOTTOM\n    }\n\n    export class Display {\n        ctx: Image\n        elements: Element[]\n        constructor() {\n            this.ctx = image.create(screen.width, screen.height)\n            this.elements = []\n        }\n        clear() {\n            this.ctx.fill(game.Color.Black)\n        }\n        draw() {\n            for (let element of this.elements) {\n                element.draw(this.ctx)\n            }\n        }\n        show() {\n            scene.setBackgroundImage(this.ctx)\n        }\n        clicked(position: Vector2) {\n            for (let element of this.elements) {\n                this.clickedOn(element, position)\n            }\n        }\n        private clickedOn(element: Element, position: Vector2) {\n            if (element instanceof Container) {\n                let container = element as Container\n                for (let child of container.children) {\n                    this.clickedOn(child, position)\n                }\n            }\n            if (element instanceof Clickable) {\n                let clickable = element as Clickable\n                if (clickable.clickable && clickable.pointInside(position)) {\n                    clickable.onClick(position)\n                }\n            }\n        }\n    }\n\n    interface Border {\n        border: boolean\n        setBorder(on: boolean): Element\n        borderColor: color\n        setBorderColor(color: color): Element\n        borderWidth: number\n        setBorderWidth(width: number): Element\n    }\n\n    interface Position {\n        position: Vector2\n        setPosition(position: Vector2): Element\n        positionMethod: PositionMethod\n        setPositionMethod(method: PositionMethod): Element\n        size: Vector2\n        setSize(size: Vector2): Element\n    }\n\n    interface Color {\n        color: color\n        setColor(color: color): Element\n    }\n\n    interface Click {\n        clickable: boolean\n        pointInside(position: Vector2): boolean\n        onClick: (position: Vector2) => void\n        setOnClick(onClick: (position: Vector2) => void): Element\n    }\n\n    class Element implements Position {\n        parent: Container\n        position: Vector2\n        size: Vector2\n        positionMethod: PositionMethod\n        constructor(position: Vector2, size: Vector2) {\n            this.parent = null\n            this.position = position\n            this.size = size\n        }\n\n        draw(ctx: Image): void { }\n\n        setParent(container: Container): void {\n            this.parent = container\n            container.children.push(this)\n        }\n\n        setPosition(position: Vector2): Element {\n            this.position = position\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Element {\n            this.positionMethod = method\n            return this\n        }\n\n        setSize(size: Vector2): Element {\n            this.size = size\n            return this\n        }\n    }\n\n    class Clickable extends Element implements Click {\n        clickable: boolean\n        onClick: (position: Vector2) => void\n\n        constructor(position: Vector2, size: Vector2) {\n            super(position, size)\n            this.clickable = false\n        }\n\n        pointInside(position: Vector2): boolean {\n            return false\n        }\n\n        setOnClick(onClick: (position: Vector2) => void): Clickable {\n            this.onClick = onClick\n            this.clickable = true\n            return this\n        }\n    }\n\n    export enum FontSize {\n        Small,\n        Medium,\n        Large\n    }\n    export enum TextWrapMode {\n        Wrap,\n        Cut,\n        Continue,\n        Ellipsis\n        // scroll text?\n    }\n    export class TextElement extends Element {\n        text: string\n        color: color\n        fontSize: FontSize\n        \n        constructor(position: Vector2, text: string, color?: color) {\n            super(position, Vector2.zero)\n            this.color = color ? color : game.Color.Black\n            this.fontSize = FontSize.Small\n            this.setText(text)\n        }\n\n        private get font(): image.Font {\n            switch (this.fontSize) {\n                case FontSize.Small: {\n                    return image.font5\n                    break\n                }\n                case FontSize.Medium: {\n                    return image.font8\n                    break\n                }\n                case FontSize.Large: {\n                    return image.font12\n                    break\n                }\n            }\n        }\n\n        private static textGridSize(text: string): Vector2 {\n            let rows = text.split(\"\\n\")\n            let maxColumns = rows.reduce((max: number, current: string) => {\n                return Math.max(max, current.replace(\"\\n\", \"\").length)\n            }, 0)\n            return new Vector2(rows.length, maxColumns)\n        }\n\n        private sizeOfText(text: string): Vector2 {\n            let gridSize = TextElement.textGridSize(text)\n            switch (this.fontSize) {\n                case FontSize.Small: {\n                    gridSize.x *= 5\n                    gridSize.y *= 7\n                    break\n                }\n                case FontSize.Medium: {\n                    gridSize.x *= 6\n                    gridSize.y *= 10\n                    break\n                }\n                case FontSize.Large: {\n                    gridSize.x *= 12\n                    gridSize.y *= 14\n                    break\n                }\n            }\n            return gridSize\n        }\n\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    ctx.print(this.text, 0, 0, this.color, this.font)\n                    break\n                }\n            }\n        }\n\n        setText(text: string): TextElement {\n            this.text = text\n            this.setSize(this.sizeOfText(this.text))\n            return this\n        }\n\n        setTextSize(size: FontSize): TextElement {\n            this.fontSize = size\n            return this\n        }\n    }\n\n    export class ImageElement extends Element {\n        img: Image\n        constructor(position: Vector2, img: Image) {\n            super(position, new Vector2(img.width, img.height))\n            this.img = img\n        }\n\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    ctx.blit(\n                        this.position.x - this.size.x / 2,\n                        this.position.y - this.size.y / 2,\n                        this.size.x, this.size.y,\n                        this.img, 0, 0,\n                        this.size.x, this.size.y,\n                        true, false\n                    )\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    ctx.blit(\n                        this.position.x, this.position.y,\n                        this.size.x, this.size.y,\n                        this.img, 0, 0,\n                        this.size.x, this.size.y,\n                        true, false\n                    )\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): ImageElement {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(position: Vector2): ImageElement {\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): ImageElement {\n            super.setPositionMethod(method)\n            return this\n        }\n    }\n\n    export class Box extends Clickable implements Border, Color {\n        color: color\n\n        border: boolean\n        borderColor: color\n        borderWidth: number\n\n        constructor(position: Vector2, size: Vector2, color?: color) {\n            super(position, size)\n            this.positionMethod = PositionMethod.CENTER\n\n            this.color = color ? color : game.Color.Tan\n\n            this.border = false\n            this.borderWidth = 1\n            this.borderColor = game.Color.Black\n        }\n\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    if (this.border) {\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2, this.position.y - this.size.y / 2,\n                            this.size.x, this.size.y,\n                            this.borderColor\n                        )\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2 + this.borderWidth,\n                            this.position.y - this.size.y / 2 + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillRect(\n                            this.position.x - this.size.x / 2, this.position.y - this.size.y / 2,\n                            this.size.x, this.size.y,\n                            this.color\n                        )\n                    }\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    if (this.border) {\n                        ctx.fillRect(\n                            this.position.x, this.position.y,\n                            this.size.x, this.size.y,\n                            this.borderColor\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth, this.position.y + this.borderWidth,\n                            this.size.x - this.borderWidth * 2, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillRect(\n                            this.position.x, this.position.y,\n                            this.size.x, this.size.y,\n                            this.color\n                        )\n                    }\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): Box {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(size: Vector2): Box {\n            super.setSize(size)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Box {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setColor(color: color): Box {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): Box {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): Box {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): Box {\n            this.borderWidth = width\n            return this\n        }\n\n        pointInside(position: Vector2): boolean {\n            let left, right, top, bottom\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    left = this.position.x\n                    right = this.position.x + this.size.x\n                    top = this.position.y\n                    bottom = this.position.y + this.size.y\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    left = this.position.x - this.size.x / 2\n                    right = this.position.x + this.size.x / 2\n                    top = this.position.y - this.size.y / 2\n                    bottom = this.position.y + this.size.y / 2\n                    break\n                }\n            }\n            return position.x >= left && position.x < right && position.y < bottom && position.y > top\n        }\n\n        setOnClick(onClick: (position: Vector2) => void): Box {\n            this.onClick = onClick\n            this.clickable = true\n            return this\n        }\n    }\n\n    export class Circle extends Clickable implements Border, Color {\n        radius: number\n\n        color: color\n\n        border: boolean\n        borderColor: color\n        borderWidth: number\n\n        constructor(position: Vector2, radius: number, color?: color) {\n            super(position, new Vector2(radius * 2, radius * 2))\n            this.positionMethod = PositionMethod.CENTER\n            this.radius = radius\n\n            this.color = color ? color : game.Color.Tan\n\n            this.border = false\n            this.borderColor = game.Color.Black\n            this.borderWidth = 1\n        }\n        draw(ctx: Image): void {\n            switch (this.positionMethod) {\n                case PositionMethod.CENTER: {\n                    if (this.border) {\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius, this.borderColor)\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius - this.borderWidth, this.color)\n                    } else {\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius, this.color)\n                    }\n                    break\n                }\n                case PositionMethod.TOP_LEFT: {\n                    if (this.border) {\n                        this.singleCircle(ctx, this.position.x - this.radius, this.position.y - this.radius, this.radius, this.borderColor)\n                        this.singleCircle(ctx, this.position.x - this.radius, this.position.y - this.radius, this.radius - this.borderWidth, this.color)\n                    } else {\n                        this.singleCircle(ctx, this.position.x, this.position.y, this.radius, this.color)\n                    }\n                    break\n                }\n            }\n        }\n\n        private singleCircle(ctx: Image, x: number, y: number, radius: number, color: number) {\n            ctx.fillCircle(x - 1, y - 1, radius, color)\n            ctx.fillCircle(x - 1, y, radius, color)\n            ctx.fillCircle(x, y - 1, radius, color)\n            ctx.fillCircle(x, y, radius, color)\n        }\n\n        setPosition(position: Vector2): Circle {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(size: Vector2): Circle {\n            super.setSize(size)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Circle {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setColor(color: color): Circle {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): Circle {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): Circle {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): Circle {\n            this.borderWidth = width\n            return this\n        }\n\n        pointInside(position: Vector2): boolean {\n            return Vector2.distance(this.position, position) < this.radius\n        }\n\n        setOnClick(onClick: (position: Vector2) => void): Circle {\n            this.onClick = onClick\n            this.clickable = true\n            return this\n        }\n    }\n\n    export class RoundedBox extends Box {\n        cornerRadius: number\n        constructor(position: Vector2, size: Vector2, cornerRadius: number, color?: color) {\n            super(position, size, color)\n            this.cornerRadius = cornerRadius\n        }\n        draw(ctx: Image) {\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    let cornerRadius = Math.min(this.cornerRadius, Math.ceil(Math.min(this.size.x, this.size.y) / 2) - 1)\n                    let left = this.position.x + cornerRadius - 1\n                    let right = this.position.x + this.size.x - cornerRadius\n                    let top = this.position.y + cornerRadius - 1\n                    let bottom = this.position.y + this.size.y - cornerRadius\n                    if (this.border) {\n                        ctx.fillCircle(left, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.borderColor)\n\n                        ctx.fillRect(left, this.position.y, right - left, this.size.y, this.borderColor)\n                        ctx.fillRect(this.position.x, top, this.size.x, bottom - top, this.borderColor)\n\n                        ctx.fillCircle(left, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius - this.borderWidth, this.color)\n\n                        ctx.fillRect(\n                            left, this.position.y + this.borderWidth,\n                            right - left, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth, top,\n                            this.size.x - this.borderWidth * 2, bottom - top,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillCircle(left, top, cornerRadius, this.color)\n                        ctx.fillCircle(right, top, cornerRadius, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.color)\n\n                        ctx.fillRect(left, this.position.y, right - left, this.size.y, this.color)\n                        ctx.fillRect(this.position.x, top, this.size.x, bottom - top, this.color)\n                    }\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    let cornerRadius = Math.min(this.cornerRadius, Math.round(Math.min(this.size.x, this.size.y) / 2))\n                    let left = this.position.x - this.size.x / 2 + cornerRadius - 1\n                    let right = this.position.x + this.size.x / 2 - cornerRadius\n                    let top = this.position.y - this.size.y / 2 + cornerRadius - 1\n                    let bottom = this.position.y + this.size.y / 2 - cornerRadius\n\n                    if (this.border) {\n                        ctx.fillCircle(left, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, top, cornerRadius, this.borderColor)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.borderColor)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.borderColor)\n\n                        ctx.fillRect(left, this.position.y - this.size.y / 2, right - left, this.size.y, this.borderColor)\n                        ctx.fillRect(this.position.x - this.size.x / 2, top, this.size.x, bottom - top, this.borderColor)\n\n                        ctx.fillCircle(left, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, top, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius - this.borderWidth, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius - this.borderWidth, this.color)\n\n                        ctx.fillRect(\n                            left, this.position.y - this.size.y / 2 + this.borderWidth,\n                            right - left, this.size.y - this.borderWidth * 2,\n                            this.color\n                        )\n                        ctx.fillRect(\n                            this.position.x + this.borderWidth - this.size.x / 2, top,\n                            this.size.x - this.borderWidth * 2, bottom - top,\n                            this.color\n                        )\n                    } else {\n                        ctx.fillCircle(left, top, cornerRadius, this.color)\n                        ctx.fillCircle(right, top, cornerRadius, this.color)\n                        ctx.fillCircle(left, bottom, cornerRadius, this.color)\n                        ctx.fillCircle(right, bottom, cornerRadius, this.color)\n\n                        ctx.fillRect(left, this.position.y - this.size.y / 2, right - left, this.size.y, this.color)\n                        ctx.fillRect(this.position.x - this.size.x / 2, top, this.size.x, bottom - top, this.color)\n                    }\n\n                    break\n                }\n            }\n        }\n\n        setPosition(position: Vector2): Box {\n            super.setPosition(position)\n            return this\n        }\n\n        setSize(size: Vector2): Box {\n            super.setSize(size)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): Box {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setColor(color: color): RoundedBox {\n            this.color = color\n            return this\n        }\n\n        setBorder(on: boolean): RoundedBox {\n            this.border = on\n            return this\n        }\n\n        setBorderColor(color: color): RoundedBox {\n            this.borderColor = color\n            return this\n        }\n\n        setBorderWidth(width: number): RoundedBox {\n            this.borderWidth = width\n            return this\n        }\n    }\n\n    class Container extends Element {\n        children: Element[]\n        shape: Clickable\n        constructor(position: Vector2, size: Vector2) {\n            super(position, size)\n            this.children = []\n        }\n\n        update() {\n            for (let child of this.children) {\n                if (child instanceof Container) {\n                    child.update()\n                }\n            }\n        }\n\n        draw(ctx: Image) {\n            this.update()\n            if (this.shape != null) {\n                this.shape.setPosition(this.position)\n                this.shape.setPositionMethod(this.positionMethod)\n                this.shape.setSize(this.size)\n                this.shape.draw(ctx)\n            }\n            for (let child of this.children) {\n                child.draw(ctx)\n            }\n        }\n\n        setPosition(position: Vector2): Container {\n            this.position = position\n            return this\n        }\n        setSize(size: Vector2): Container {\n            this.size = size\n            return this\n        }\n        setPositionMethod(method: PositionMethod): Container {\n            this.positionMethod = method\n            return this\n        }\n        setShape(shape: Clickable): Container {\n            this.shape = shape\n            return this\n        }\n        addChild(child: Element): Container {\n            child.setParent(this)\n            return this\n        }\n    }\n\n    export class VerticalStack extends Container {\n        spacing: number\n        alignmentMethod: AlignmentMethodH\n\n        constructor(position: Vector2, children?: Element[]) {\n            super(position, Vector2.zero)\n            this.spacing = 0\n            if (children) {\n                this.children = children\n                this.update()\n            }\n            this.alignmentMethod = AlignmentMethodH.CENTER\n        }\n\n        update(): void {\n            super.update()\n            this.size = new Vector2(0, this.spacing)\n            for (let child of this.children) {\n                this.size.y += child.size.y\n                this.size.y += this.spacing\n                this.size.x = Math.max(this.size.x, child.size.x)\n            }\n\n            this.size.x += this.spacing * 2\n\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    let offset = this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodH.LEFT: {\n                                child.setPosition(new Vector2(this.position.x, this.position.y + offset))\n                                break\n                            }\n                            case AlignmentMethodH.RIGHT: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x), this.position.y + offset))\n                                break\n                            }\n                            case AlignmentMethodH.CENTER: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x) / 2, this.position.y + offset))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    let offset = -this.size.y / 2 + this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodH.LEFT: {\n                                child.setPosition(new Vector2(this.position.x - (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodH.RIGHT: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodH.CENTER: {\n                                child.setPosition(new Vector2(this.position.x, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n            }\n        }\n\n        setSpacing(spacing: number): VerticalStack {\n            this.spacing = spacing\n            return this\n        }\n\n        setAlignmentMethod(method: AlignmentMethodH): VerticalStack {\n            this.alignmentMethod = method\n            return this\n        }\n\n        setPosition(position: Vector2): VerticalStack {\n            super.setPosition(position)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): VerticalStack {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setSize(size: Vector2): VerticalStack {\n            super.setSize(size)\n            return this\n        }\n\n        setShape(shape: Clickable): VerticalStack {\n            super.setShape(shape)\n            return this\n        }\n\n        addChild(child: Element): VerticalStack {\n            super.addChild(child)\n            return this\n        }\n    }\n\n    export class HorizontalStack extends Container {\n        spacing: number\n        alignmentMethod: AlignmentMethodV\n\n        constructor(position: Vector2, children?: Element[]) {\n            super(position, Vector2.zero)\n            this.spacing = 0\n            this.alignmentMethod = AlignmentMethodV.CENTER\n            if (children) {\n                this.children = children\n                this.update()\n            }\n        }\n\n        update(): void {\n            super.update()\n            this.size = new Vector2(this.spacing, 0)\n            for (let child of this.children) {\n                this.size.x += child.size.x\n                this.size.x += this.spacing\n                this.size.y = Math.max(this.size.y, child.size.y)\n            }\n\n            switch (this.positionMethod) {\n                case PositionMethod.TOP_LEFT: {\n                    let offset = this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodV.TOP: {\n                                child.setPosition(new Vector2(this.position.x + offset, this.position.y))\n                                break\n                            }\n                            case AlignmentMethodV.BOTTOM: {\n                                child.setPosition(new Vector2(this.position.x + offset, this.position.y + (this.size.y - child.size.y)))\n                                break\n                            }\n                            case AlignmentMethodV.CENTER: {\n                                child.setPosition(new Vector2(this.position.x + offset, this.position.y + (this.size.y - child.size.y) / 2))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n                case PositionMethod.CENTER: {\n                    let offset = -this.size.y / 2 + this.spacing\n                    for (let child of this.children) {\n                        switch (this.alignmentMethod) {\n                            case AlignmentMethodV.TOP: {\n                                child.setPosition(new Vector2(this.position.x - (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodV.BOTTOM: {\n                                child.setPosition(new Vector2(this.position.x + (this.size.x - child.size.x) / 2, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                            case AlignmentMethodV.CENTER: {\n                                child.setPosition(new Vector2(this.position.x, this.position.y + offset + child.size.y / 2))\n                                break\n                            }\n                        }\n                        offset += child.size.y\n                        offset += this.spacing\n                    }\n                    break\n                }\n            }\n        }\n\n        setSpacing(spacing: number): HorizontalStack {\n            this.spacing = spacing\n            return this\n        }\n\n        setAlignmentMethod(method: AlignmentMethodV): HorizontalStack {\n            this.alignmentMethod = method\n            return this\n        }\n\n        setPosition(position: Vector2): HorizontalStack {\n            super.setPosition(position)\n            return this\n        }\n\n        setPositionMethod(method: PositionMethod): HorizontalStack {\n            super.setPositionMethod(method)\n            return this\n        }\n\n        setSize(size: Vector2): HorizontalStack {\n            super.setSize(size)\n            return this\n        }\n\n        setShape(shape: Clickable): HorizontalStack {\n            super.setShape(shape)\n            return this\n        }\n\n        addChild(child: Element): HorizontalStack {\n            super.addChild(child)\n            return this\n        }\n    }\n\n    export class DepthStack extends Container {\n        spacing: number\n        alignmentMethodH: AlignmentMethodH\n        alignmentMethodV: AlignmentMethodV\n        constructor(position: Vector2, children?: Element[]) {\n            super(position, Vector2.zero)\n            if (children) {\n                this.children = children\n                this.update()\n            }\n            this.alignmentMethodH = AlignmentMethodH.CENTER\n            this.alignmentMethodV = AlignmentMethodV.CENTER\n            this.spacing = 0\n        }\n        update(): void {\n            super.update()\n            this.size = Vector2.zero\n            for (let child of this.children) {\n                child.setPositionMethod(this.positionMethod)\n                this.size = new Vector2(Math.max(this.size.x, child.size.x), Math.max(this.size.y, child.size.y))\n            }\n            this.size.x += this.spacing * 2\n            this.size.y += this.spacing * 2\n            for (let child of this.children) {\n                switch (this.positionMethod) {\n                    case PositionMethod.CENTER: {\n                        let position = Vector2.zero\n                        switch (this.alignmentMethodH) {\n                            case AlignmentMethodH.LEFT: {\n                                position.x = this.position.x - (this.size.x / 2 - this.spacing) + child.size.x / 2\n                                break\n                            }\n                            case AlignmentMethodH.CENTER: {\n                                position.x = this.position.x\n                                break\n                            }\n                            case AlignmentMethodH.RIGHT: {\n                                position.x = this.position.x + (this.size.x / 2 - this.spacing) - child.size.x / 2\n                                break\n                            }\n                        }\n                        switch (this.alignmentMethodV) {\n                            case AlignmentMethodV.TOP: {\n                                position.y = this.position.y - (this.size.y / 2 - this.spacing) + child.size.y / 2\n                                break\n                            }\n                            case AlignmentMethodV.CENTER: {\n                                position.y = this.position.y\n                                break\n                            }\n                            case AlignmentMethodV.BOTTOM: {\n                                position.y = this.position.y + (this.size.y / 2 - this.spacing) - child.size.y / 2\n                                break\n                            }\n                        }\n                        child.setPosition(position)\n                        break\n                    }\n                    case PositionMethod.TOP_LEFT: {\n                        let position = Vector2.zero\n                        switch (this.alignmentMethodH) {\n                            case AlignmentMethodH.LEFT: {\n                                position.x = this.position.x - (this.size.x / 2 - this.spacing) + child.size.x / 2\n                                break\n                            }\n                            case AlignmentMethodH.CENTER: {\n                                position.x = this.position.x\n                                break\n                            }\n                            case AlignmentMethodH.RIGHT: {\n                                position.x = this.position.x + (this.size.x / 2 - this.spacing) - child.size.x / 2\n                                break\n                            }\n                        }\n                        switch (this.alignmentMethodV) {\n                            case AlignmentMethodV.TOP: {\n                                position.y = this.position.y - (this.size.y / 2 - this.spacing) + child.size.y / 2\n                                break\n                            }\n                            case AlignmentMethodV.CENTER: {\n                                position.y = this.position.y\n                                break\n                            }\n                            case AlignmentMethodV.BOTTOM: {\n                                position.y = this.position.y + (this.size.y / 2 - this.spacing) - child.size.y / 2\n                                break\n                            }\n                        }\n                        position.x += this.size.x / 2\n                        position.y += this.size.y / 2\n                        child.setPosition(position)\n                        break\n                    }\n                }\n            }\n        }\n\n        setPosition(position: Vector2): DepthStack {\n            super.setPosition(position)\n            return this\n        }\n        setSize(size: Vector2): DepthStack {\n            super.setSize(size)\n            return this\n        }\n        setPositionMethod(method: PositionMethod): DepthStack {\n            super.setPositionMethod(method)\n            return this\n        }\n        setShape(shape: Clickable): DepthStack {\n            super.setShape(shape)\n            return this\n        }\n        addChild(child: Element): DepthStack {\n            super.addChild(child)\n            return this\n        }\n        setSpacing(spacing: number): DepthStack {\n            this.spacing = spacing\n            return this\n        }\n    }\n\n    export class Grid extends Container {\n        spacing: number\n\n        \n    }\n}","util.ts":"class Vector2 {\n    x: number\n    y: number\n    constructor(x: number, y: number) {\n        this.x = x\n        this.y = y\n    }\n\n    scale(scalar: number) {\n        this.x *= scalar\n        this.y *= scalar\n    }\n\n    static get zero(): Vector2 {\n        return new Vector2(0, 0)\n    }\n\n    static distance(a: Vector2, b: Vector2): number {\n        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2))\n    }\n\n    toString(): string {\n        return `x: ${this.x}, y: ${this.y}`\n    }\n}","images.g.jres":"{\n    \"image1\": {\n        \"data\": \"hwQIAAgAAAAA8A8AAPAPAADwDwD//////////wDwDwAA8A8AAPAPAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"plus_icon\"\n    },\n    \"image2\": {\n        \"data\": \"hwQIAAgAAAAA8A8AAPAPAADwDwAA8A8AAPAPAADwDwAA8A8AAPAPAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"minus_icon\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myImages\"\n    }\n}","images.g.ts":"","pxt.json":"{\n    \"name\": \"ui\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"browser-events\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"ui.ts\",\n        \"util.ts\",\n        \"images.g.jres\",\n        \"images.g.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}}],"shares":[{"id":"00579-74530-22418-83871","timestamp":1744641767694}],"lastSaveTime":1758229035325}